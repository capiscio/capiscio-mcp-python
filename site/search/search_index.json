{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"capiscio-mcp","text":"<p>Trust badges for MCP tool calls.</p> <p>capiscio-mcp provides trust badges and identity verification for Model Context Protocol (MCP) tool calls, implementing:</p> <ul> <li>RFC-006: MCP Tool Authority and Evidence</li> <li>RFC-007: MCP Server Identity Disclosure and Verification</li> </ul>"},{"location":"#why-capiscio-mcp","title":"Why capiscio-mcp?","text":"<p>MCP servers expose powerful tools to autonomous agents\u2014file systems, databases, APIs. But MCP itself doesn't define how to:</p> <ul> <li>Authenticate which agent is calling a tool</li> <li>Authorize whether that agent should have access</li> <li>Audit what happened for post-incident review</li> </ul> <p>capiscio-mcp solves this with:</p> Feature Description @guard decorator Protect tools with trust-level requirements Evidence logging Cryptographic audit trail for every invocation Server identity Verify MCP servers before connecting Trust levels 0 (self-signed) \u2192 4 (continuous validation)"},{"location":"#quick-example","title":"Quick Example","text":""},{"location":"#server-side-protect-your-tools","title":"Server-Side (Protect Your Tools)","text":"<pre><code>from capiscio_mcp import guard\n\n@guard(min_trust_level=2)\nasync def read_database(query: str) -&gt; list[dict]:\n    \"\"\"Only agents with Trust Level 2+ can execute this tool.\"\"\"\n    pass\n</code></pre>"},{"location":"#client-side-verify-servers","title":"Client-Side (Verify Servers)","text":"<pre><code>from capiscio_mcp import verify_server, ServerState\n\nresult = await verify_server(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n)\n\nif result.state == ServerState.VERIFIED_PRINCIPAL:\n    print(f\"Trusted server at Level {result.trust_level}\")\n</code></pre>"},{"location":"#trust-levels","title":"Trust Levels","text":"Level Name Description 0 Self-Signed <code>did:key</code> issuer, cryptographic identity only 1 Domain Validated (DV) Domain ownership verified 2 Organization Validated (OV) Organization identity verified 3 Extended Validation (EV) Legal entity verification 4 Continuous Validation (CV) Runtime attestation"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-download:{ .lg .middle } Installation</p> <p>Install capiscio-mcp and configure your environment.</p> <p>:octicons-arrow-right-24: Installation</p> </li> <li> <p>:material-rocket-launch:{ .lg .middle } Quickstart</p> <p>Get started in 5 minutes with the @guard decorator.</p> <p>:octicons-arrow-right-24: Quickstart</p> </li> <li> <p>:material-shield-check:{ .lg .middle } Server-Side Guide</p> <p>Protect your MCP tools with trust-level requirements.</p> <p>:octicons-arrow-right-24: Server-Side</p> </li> <li> <p>:material-check-decagram:{ .lg .middle } Client-Side Guide</p> <p>Verify MCP server identity before connecting.</p> <p>:octicons-arrow-right-24: Client-Side</p> </li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>RFC-006: MCP Tool Authority and Evidence</li> <li>RFC-007: MCP Server Identity Disclosure</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section provides detailed API documentation for all public modules in capiscio-mcp.</p>"},{"location":"api-reference/#core-exports","title":"Core Exports","text":"<p>capiscio-mcp: Trust badges for MCP tool calls.</p> <p>RFC-006: MCP Tool Authority and Evidence RFC-007: MCP Server Identity Disclosure and Verification</p> <p>This package provides: - @guard decorator for protecting MCP tools with trust-level requirements - Server identity verification for MCP clients - PoP (Proof of Possession) handshake for server key verification - Evidence logging for audit and forensics</p> Installation <p>pip install capiscio-mcp          # Standalone pip install capiscio-mcp[mcp]     # With MCP SDK integration pip install capiscio-mcp[crypto]  # With PoP signing/verification</p> <p>Quickstart (Server-side):     from capiscio_mcp import guard</p> <pre><code>@guard(min_trust_level=2)\nasync def read_database(query: str) -&gt; list[dict]:\n    ...\n</code></pre> <p>Quickstart (Client-side):     from capiscio_mcp import verify_server, ServerState</p> <pre><code>result = await verify_server(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n)\nif result.state == ServerState.VERIFIED_PRINCIPAL:\n    print(f\"Trusted at level {result.trust_level}\")\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.GuardConfig","title":"<code>GuardConfig</code>  <code>dataclass</code>","text":"<p>Configuration for the @guard decorator.</p> <p>Attributes:</p> Name Type Description <code>min_trust_level</code> <code>int</code> <p>Minimum trust level required (0-4, default 0)</p> <code>accept_level_zero</code> <code>bool</code> <p>Accept self-signed (did:key) badges</p> <code>trusted_issuers</code> <code>Optional[List[str]]</code> <p>List of trusted issuer DIDs</p> <code>allowed_tools</code> <code>Optional[List[str]]</code> <p>Glob patterns for allowed tool names</p> <code>policy_version</code> <code>Optional[str]</code> <p>Policy version string for tracking</p> <code>require_badge</code> <code>bool</code> <p>If True, deny anonymous/API key access</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>@dataclass\nclass GuardConfig:\n    \"\"\"\n    Configuration for the @guard decorator.\n\n    Attributes:\n        min_trust_level: Minimum trust level required (0-4, default 0)\n        accept_level_zero: Accept self-signed (did:key) badges\n        trusted_issuers: List of trusted issuer DIDs\n        allowed_tools: Glob patterns for allowed tool names\n        policy_version: Policy version string for tracking\n        require_badge: If True, deny anonymous/API key access\n    \"\"\"\n    min_trust_level: int = 0\n    accept_level_zero: bool = False\n    trusted_issuers: Optional[List[str]] = None\n    allowed_tools: Optional[List[str]] = None\n    policy_version: Optional[str] = None\n    require_badge: bool = False\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration on creation.\"\"\"\n        self.validate()\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate configuration values.\"\"\"\n        if not 0 &lt;= self.min_trust_level &lt;= 4:\n            raise GuardConfigError(\n                f\"min_trust_level must be 0-4, got {self.min_trust_level}\"\n            )\n\n        if self.min_trust_level == 0 and not self.accept_level_zero:\n            # Level 0 is self-signed, must explicitly opt-in\n            pass  # This is fine, will deny Level 0 badges\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.GuardConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate configuration on creation.</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration on creation.\"\"\"\n    self.validate()\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.GuardConfig.validate","title":"<code>validate()</code>","text":"<p>Validate configuration values.</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate configuration values.\"\"\"\n    if not 0 &lt;= self.min_trust_level &lt;= 4:\n        raise GuardConfigError(\n            f\"min_trust_level must be 0-4, got {self.min_trust_level}\"\n        )\n\n    if self.min_trust_level == 0 and not self.accept_level_zero:\n        # Level 0 is self-signed, must explicitly opt-in\n        pass  # This is fine, will deny Level 0 badges\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.GuardResult","title":"<code>GuardResult</code>  <code>dataclass</code>","text":"<p>Result from tool access evaluation.</p> <p>Attributes:</p> Name Type Description <code>decision</code> <code>Decision</code> <p>ALLOW or DENY</p> <code>deny_reason</code> <code>Optional[DenyReason]</code> <p>Reason for denial (if decision is DENY)</p> <code>deny_detail</code> <code>Optional[str]</code> <p>Human-readable detail (if decision is DENY)</p> <code>agent_did</code> <code>Optional[str]</code> <p>Extracted agent DID from credential</p> <code>badge_jti</code> <code>Optional[str]</code> <p>Badge ID if present</p> <code>auth_level</code> <code>AuthLevel</code> <p>Authentication level (ANONYMOUS, API_KEY, BADGE)</p> <code>trust_level</code> <code>int</code> <p>Verified trust level (0-4)</p> <code>evidence_id</code> <code>str</code> <p>Unique evidence record ID</p> <code>evidence_json</code> <code>str</code> <p>RFC-006 \u00a77 compliant JSON</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>@dataclass\nclass GuardResult:\n    \"\"\"\n    Result from tool access evaluation.\n\n    Attributes:\n        decision: ALLOW or DENY\n        deny_reason: Reason for denial (if decision is DENY)\n        deny_detail: Human-readable detail (if decision is DENY)\n        agent_did: Extracted agent DID from credential\n        badge_jti: Badge ID if present\n        auth_level: Authentication level (ANONYMOUS, API_KEY, BADGE)\n        trust_level: Verified trust level (0-4)\n        evidence_id: Unique evidence record ID\n        evidence_json: RFC-006 \u00a77 compliant JSON\n    \"\"\"\n    decision: Decision\n    deny_reason: Optional[DenyReason] = None\n    deny_detail: Optional[str] = None\n\n    # Derived identity\n    agent_did: Optional[str] = None\n    badge_jti: Optional[str] = None\n    auth_level: AuthLevel = AuthLevel.ANONYMOUS\n    trust_level: int = 0\n\n    # Evidence\n    evidence_id: str = \"\"\n    evidence_json: str = \"\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.GuardError","title":"<code>GuardError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when tool access is denied by the guard.</p> <p>Per RFC-006, all denials include: - reason: Specific denial reason code - detail: Human-readable explanation - evidence_id: ID of the evidence record for audit</p> Example <p>try:     result = await guarded_tool(params) except GuardError as e:     logger.warning(f\"Access denied: {e.reason} - {e.detail}\")     logger.info(f\"Evidence ID: {e.evidence_id}\")</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class GuardError(CapiscioMCPError):\n    \"\"\"\n    Raised when tool access is denied by the guard.\n\n    Per RFC-006, all denials include:\n    - reason: Specific denial reason code\n    - detail: Human-readable explanation\n    - evidence_id: ID of the evidence record for audit\n\n    Example:\n        try:\n            result = await guarded_tool(params)\n        except GuardError as e:\n            logger.warning(f\"Access denied: {e.reason} - {e.detail}\")\n            logger.info(f\"Evidence ID: {e.evidence_id}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        reason: \"DenyReason\",\n        detail: str,\n        evidence_id: str = \"\",\n        agent_did: Optional[str] = None,\n        trust_level: Optional[int] = None,\n    ):\n        self.reason = reason\n        self.detail = detail\n        self.evidence_id = evidence_id\n        self.agent_did = agent_did\n        self.trust_level = trust_level\n\n        message = f\"{reason.value}: {detail}\"\n        if evidence_id:\n            message += f\" (evidence_id={evidence_id})\"\n\n        super().__init__(message)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"GuardError(reason={self.reason!r}, detail={self.detail!r}, \"\n            f\"evidence_id={self.evidence_id!r})\"\n        )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.VerifyConfig","title":"<code>VerifyConfig</code>  <code>dataclass</code>","text":"<p>Configuration for server identity verification.</p> <p>Attributes:</p> Name Type Description <code>trusted_issuers</code> <code>Optional[List[str]]</code> <p>List of trusted issuer DIDs</p> <code>min_trust_level</code> <code>int</code> <p>Minimum trust level required (0-4)</p> <code>accept_level_zero</code> <code>bool</code> <p>Accept self-signed (did:key) servers</p> <code>offline_mode</code> <code>bool</code> <p>Skip revocation checks</p> <code>skip_origin_binding</code> <code>bool</code> <p>Skip host/path binding checks (for trusted gateways)</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>@dataclass\nclass VerifyConfig:\n    \"\"\"\n    Configuration for server identity verification.\n\n    Attributes:\n        trusted_issuers: List of trusted issuer DIDs\n        min_trust_level: Minimum trust level required (0-4)\n        accept_level_zero: Accept self-signed (did:key) servers\n        offline_mode: Skip revocation checks\n        skip_origin_binding: Skip host/path binding checks (for trusted gateways)\n    \"\"\"\n    trusted_issuers: Optional[List[str]] = None\n    min_trust_level: int = 0\n    accept_level_zero: bool = False\n    offline_mode: bool = False\n    skip_origin_binding: bool = False\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.VerifyResult","title":"<code>VerifyResult</code>  <code>dataclass</code>","text":"<p>Result of server identity verification.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ServerState</code> <p>Server classification state (VERIFIED_PRINCIPAL, DECLARED_PRINCIPAL, UNVERIFIED_ORIGIN)</p> <code>trust_level</code> <code>Optional[int]</code> <p>Trust level if verified (0-4)</p> <code>server_did</code> <code>Optional[str]</code> <p>Server DID if disclosed</p> <code>badge_jti</code> <code>Optional[str]</code> <p>Badge ID if present</p> <code>error_code</code> <code>ServerErrorCode</code> <p>Error code if verification failed</p> <code>error_detail</code> <code>Optional[str]</code> <p>Human-readable error detail</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>@dataclass\nclass VerifyResult:\n    \"\"\"\n    Result of server identity verification.\n\n    Attributes:\n        state: Server classification state (VERIFIED_PRINCIPAL, DECLARED_PRINCIPAL, UNVERIFIED_ORIGIN)\n        trust_level: Trust level if verified (0-4)\n        server_did: Server DID if disclosed\n        badge_jti: Badge ID if present\n        error_code: Error code if verification failed\n        error_detail: Human-readable error detail\n    \"\"\"\n    state: ServerState\n    trust_level: Optional[int] = None\n\n    # Derived identity\n    server_did: Optional[str] = None\n    badge_jti: Optional[str] = None\n\n    # Error details\n    error_code: ServerErrorCode = ServerErrorCode.NONE\n    error_detail: Optional[str] = None\n\n    @property\n    def is_verified(self) -&gt; bool:\n        \"\"\"Check if server identity is cryptographically verified.\"\"\"\n        return self.state == ServerState.VERIFIED_PRINCIPAL\n\n    @property\n    def has_identity(self) -&gt; bool:\n        \"\"\"Check if server disclosed any identity.\"\"\"\n        return self.state != ServerState.UNVERIFIED_ORIGIN\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.VerifyResult.has_identity","title":"<code>has_identity</code>  <code>property</code>","text":"<p>Check if server disclosed any identity.</p>"},{"location":"api-reference/#capiscio_mcp.VerifyResult.is_verified","title":"<code>is_verified</code>  <code>property</code>","text":"<p>Check if server identity is cryptographically verified.</p>"},{"location":"api-reference/#capiscio_mcp.Decision","title":"<code>Decision</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Tool access decision result.</p> <p>Per RFC-006 \u00a76.3, every tool invocation attempt results in one of: - ALLOW: Tool execution is permitted - DENY: Tool execution is blocked with a reason</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class Decision(str, Enum):\n    \"\"\"\n    Tool access decision result.\n\n    Per RFC-006 \u00a76.3, every tool invocation attempt results in one of:\n    - ALLOW: Tool execution is permitted\n    - DENY: Tool execution is blocked with a reason\n    \"\"\"\n    ALLOW = \"allow\"\n    DENY = \"deny\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.AuthLevel","title":"<code>AuthLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Caller authentication assurance level.</p> <p>Per RFC-006 \u00a75, every evidence log records the authentication method: - ANONYMOUS: No identity material provided - API_KEY: API key authentication (reduced assurance) - BADGE: CapiscIO Trust Badge authentication (full assurance)</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class AuthLevel(str, Enum):\n    \"\"\"\n    Caller authentication assurance level.\n\n    Per RFC-006 \u00a75, every evidence log records the authentication method:\n    - ANONYMOUS: No identity material provided\n    - API_KEY: API key authentication (reduced assurance)\n    - BADGE: CapiscIO Trust Badge authentication (full assurance)\n    \"\"\"\n    ANONYMOUS = \"anonymous\"\n    API_KEY = \"api_key\"\n    BADGE = \"badge\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.DenyReason","title":"<code>DenyReason</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Reason for denying tool access.</p> <p>Per RFC-006 \u00a76.4, denial must include a specific reason code.</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class DenyReason(str, Enum):\n    \"\"\"\n    Reason for denying tool access.\n\n    Per RFC-006 \u00a76.4, denial must include a specific reason code.\n    \"\"\"\n    # Badge issues\n    BADGE_MISSING = \"badge_missing\"           # Required but not provided\n    BADGE_INVALID = \"badge_invalid\"           # Malformed or unverifiable\n    BADGE_EXPIRED = \"badge_expired\"           # Past expiration time\n    BADGE_REVOKED = \"badge_revoked\"           # On revocation list\n\n    # Trust issues\n    TRUST_INSUFFICIENT = \"trust_insufficient\" # Trust level &lt; min required\n    ISSUER_UNTRUSTED = \"issuer_untrusted\"     # Issuer not in trusted list\n\n    # Policy issues\n    TOOL_NOT_ALLOWED = \"tool_not_allowed\"     # Tool not in allowed list\n    POLICY_DENIED = \"policy_denied\"           # Policy evaluation failed\n\n    # Other\n    INTERNAL_ERROR = \"internal_error\"         # Unexpected error\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.ServerState","title":"<code>ServerState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Server identity verification state.</p> <p>Per RFC-007 \u00a75.2, clients classify servers into three states:</p> <ul> <li> <p>VERIFIED_PRINCIPAL: Server badge verified, trust level established.   The server has disclosed a DID and a valid badge signed by a trusted issuer.</p> </li> <li> <p>DECLARED_PRINCIPAL: Server DID disclosed but badge missing or invalid.   Identity is claimed but not cryptographically verified.</p> </li> <li> <p>UNVERIFIED_ORIGIN: Server did not disclose any identity material.   This is distinct from Trust Level 0 (self-signed) - UNVERIFIED_ORIGIN   means NO identity was disclosed at all.</p> </li> </ul> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class ServerState(str, Enum):\n    \"\"\"\n    Server identity verification state.\n\n    Per RFC-007 \u00a75.2, clients classify servers into three states:\n\n    - VERIFIED_PRINCIPAL: Server badge verified, trust level established.\n      The server has disclosed a DID and a valid badge signed by a trusted issuer.\n\n    - DECLARED_PRINCIPAL: Server DID disclosed but badge missing or invalid.\n      Identity is claimed but not cryptographically verified.\n\n    - UNVERIFIED_ORIGIN: Server did not disclose any identity material.\n      This is distinct from Trust Level 0 (self-signed) - UNVERIFIED_ORIGIN\n      means NO identity was disclosed at all.\n    \"\"\"\n    VERIFIED_PRINCIPAL = \"verified_principal\"\n    DECLARED_PRINCIPAL = \"declared_principal\"\n    UNVERIFIED_ORIGIN = \"unverified_origin\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.ServerErrorCode","title":"<code>ServerErrorCode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Server identity verification error codes.</p> <p>Per RFC-007 \u00a78, verification failures include specific error codes.</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class ServerErrorCode(str, Enum):\n    \"\"\"\n    Server identity verification error codes.\n\n    Per RFC-007 \u00a78, verification failures include specific error codes.\n    \"\"\"\n    NONE = \"none\"\n    DID_INVALID = \"did_invalid\"\n    BADGE_INVALID = \"badge_invalid\"\n    BADGE_EXPIRED = \"badge_expired\"\n    BADGE_REVOKED = \"badge_revoked\"\n    TRUST_INSUFFICIENT = \"trust_insufficient\"\n    ORIGIN_MISMATCH = \"origin_mismatch\"\n    PATH_MISMATCH = \"path_mismatch\"\n    ISSUER_UNTRUSTED = \"issuer_untrusted\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard_sync","title":"<code>guard_sync(func=None, *, config=None, min_trust_level=None, tool_name=None, require_badge=False)</code>","text":"<p>Sync decorator to guard MCP tool execution.</p> <p>Same as @guard but for synchronous functions. Internally runs the async guard in an event loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[P, R]]</code> <p>Function to decorate (if called without parentheses)</p> <code>None</code> <code>config</code> <code>Optional[GuardConfig]</code> <p>Full configuration object</p> <code>None</code> <code>min_trust_level</code> <code>Optional[int]</code> <p>Shorthand for config.min_trust_level</p> <code>None</code> <code>tool_name</code> <code>Optional[str]</code> <p>Override tool name (default: function name)</p> <code>None</code> <code>require_badge</code> <code>bool</code> <p>If True, deny anonymous/API key access</p> <code>False</code> Example <p>@guard_sync(min_trust_level=2) def read_file(path: str) -&gt; str:     ...</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def guard_sync(\n    func: Optional[Callable[P, R]] = None,\n    *,\n    config: Optional[GuardConfig] = None,\n    min_trust_level: Optional[int] = None,\n    tool_name: Optional[str] = None,\n    require_badge: bool = False,\n) -&gt; Union[Callable[P, R], Callable[[Callable[P, R]], Callable[P, R]]]:\n    \"\"\"\n    Sync decorator to guard MCP tool execution.\n\n    Same as @guard but for synchronous functions.\n    Internally runs the async guard in an event loop.\n\n    Args:\n        func: Function to decorate (if called without parentheses)\n        config: Full configuration object\n        min_trust_level: Shorthand for config.min_trust_level\n        tool_name: Override tool name (default: function name)\n        require_badge: If True, deny anonymous/API key access\n\n    Example:\n        @guard_sync(min_trust_level=2)\n        def read_file(path: str) -&gt; str:\n            ...\n    \"\"\"\n    def make_decorator(f: Callable[P, R]) -&gt; Callable[P, R]:\n        # Build effective config\n        effective_config = config or GuardConfig()\n        if min_trust_level is not None:\n            effective_config.min_trust_level = min_trust_level\n        if require_badge:\n            effective_config.require_badge = True\n\n        effective_tool_name = tool_name or f.__name__\n\n        @wraps(f)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            # Build params dict from kwargs for hashing\n            params = dict(kwargs)\n\n            # Run async evaluation in event loop\n            async def run_eval():\n                return await evaluate_tool_access(\n                    tool_name=effective_tool_name,\n                    params=params,\n                    config=effective_config,\n                )\n\n            try:\n                loop = asyncio.get_running_loop()\n            except RuntimeError:\n                loop = None\n\n            if loop is not None:\n                # We're in an async context, use run_coroutine_threadsafe\n                import concurrent.futures\n                future = asyncio.run_coroutine_threadsafe(run_eval(), loop)\n                result = future.result(timeout=30.0)\n            else:\n                # No event loop, create one\n                result = asyncio.run(run_eval())\n\n            # Check decision\n            if result.decision == Decision.DENY:\n                raise GuardError(\n                    reason=result.deny_reason or DenyReason.INTERNAL_ERROR,\n                    detail=result.deny_detail or \"Access denied\",\n                    evidence_id=result.evidence_id,\n                    agent_did=result.agent_did,\n                    trust_level=result.trust_level,\n                )\n\n            # Execute tool\n            return f(*args, **kwargs)\n\n        return wrapper\n\n    # Handle both @guard_sync and @guard_sync() syntax\n    if func is not None:\n        return make_decorator(func)\n    return make_decorator\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.verify_server","title":"<code>verify_server(server_did, server_badge=None, transport_origin=None, endpoint_path=None, config=None)</code>  <code>async</code>","text":"<p>Verify MCP server identity per RFC-007 \u00a77.2.</p> <p>This function implements the client verification algorithm: 1. If no DID disclosed \u2192 UNVERIFIED_ORIGIN 2. If DID but no badge \u2192 DECLARED_PRINCIPAL 3. If DID + badge \u2192 verify badge \u2192 VERIFIED_PRINCIPAL or error</p> <p>Parameters:</p> Name Type Description Default <code>server_did</code> <code>Optional[str]</code> <p>Server DID from Capiscio-Server-DID header or _meta</p> required <code>server_badge</code> <code>Optional[str]</code> <p>Server badge JWS from Capiscio-Server-Badge header or _meta</p> <code>None</code> <code>transport_origin</code> <code>Optional[str]</code> <p>HTTP origin (e.g., \"https://mcp.example.com\")</p> <code>None</code> <code>endpoint_path</code> <code>Optional[str]</code> <p>URL path for did:web binding (e.g., \"/mcp/filesystem\")</p> <code>None</code> <code>config</code> <code>Optional[VerifyConfig]</code> <p>Verification configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>VerifyResult</code> <p>VerifyResult with state, trust_level, and any error details</p> Example <p>result = await verify_server(     server_did=\"did:web:mcp.example.com:servers:filesystem\",     server_badge=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\",     transport_origin=\"https://mcp.example.com\", )</p> <p>match result.state:     case ServerState.VERIFIED_PRINCIPAL:         print(f\"Verified at level {result.trust_level}\")     case ServerState.DECLARED_PRINCIPAL:         print(\"Identity claimed but not verified\")     case ServerState.UNVERIFIED_ORIGIN:         print(\"No identity disclosed\")</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>async def verify_server(\n    server_did: Optional[str],\n    server_badge: Optional[str] = None,\n    transport_origin: Optional[str] = None,\n    endpoint_path: Optional[str] = None,\n    config: Optional[VerifyConfig] = None,\n) -&gt; VerifyResult:\n    \"\"\"\n    Verify MCP server identity per RFC-007 \u00a77.2.\n\n    This function implements the client verification algorithm:\n    1. If no DID disclosed \u2192 UNVERIFIED_ORIGIN\n    2. If DID but no badge \u2192 DECLARED_PRINCIPAL\n    3. If DID + badge \u2192 verify badge \u2192 VERIFIED_PRINCIPAL or error\n\n    Args:\n        server_did: Server DID from Capiscio-Server-DID header or _meta\n        server_badge: Server badge JWS from Capiscio-Server-Badge header or _meta\n        transport_origin: HTTP origin (e.g., \"https://mcp.example.com\")\n        endpoint_path: URL path for did:web binding (e.g., \"/mcp/filesystem\")\n        config: Verification configuration\n\n    Returns:\n        VerifyResult with state, trust_level, and any error details\n\n    Example:\n        result = await verify_server(\n            server_did=\"did:web:mcp.example.com:servers:filesystem\",\n            server_badge=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\",\n            transport_origin=\"https://mcp.example.com\",\n        )\n\n        match result.state:\n            case ServerState.VERIFIED_PRINCIPAL:\n                print(f\"Verified at level {result.trust_level}\")\n            case ServerState.DECLARED_PRINCIPAL:\n                print(\"Identity claimed but not verified\")\n            case ServerState.UNVERIFIED_ORIGIN:\n                print(\"No identity disclosed\")\n    \"\"\"\n    from capiscio_mcp._core.client import CoreClient\n\n    effective_config = config or VerifyConfig()\n\n    # Quick path: no DID disclosed at all\n    if not server_did:\n        logger.debug(\"Server did not disclose identity (UNVERIFIED_ORIGIN)\")\n        return VerifyResult(\n            state=ServerState.UNVERIFIED_ORIGIN,\n            error_code=ServerErrorCode.NONE,\n        )\n\n    # Get core client\n    client = await CoreClient.get_instance()\n\n    # Import proto\n    from capiscio_mcp._proto.capiscio.v1 import mcp_pb2\n\n    # Build request\n    request = mcp_pb2.VerifyServerIdentityRequest(\n        server_did=server_did,\n        server_badge=server_badge or \"\",\n        transport_origin=transport_origin or \"\",\n        endpoint_path=endpoint_path or \"\",\n        config=mcp_pb2.VerifyConfig(\n            trusted_issuers=effective_config.trusted_issuers or [],\n            min_trust_level=effective_config.min_trust_level,\n            accept_level_zero=effective_config.accept_level_zero,\n            offline_mode=effective_config.offline_mode,\n            skip_origin_binding=effective_config.skip_origin_binding,\n        ),\n    )\n\n    # Make RPC call\n    response = await client.stub.VerifyServerIdentity(request)\n\n    # Map response state\n    state_map = {\n        mcp_pb2.VERIFIED_PRINCIPAL: ServerState.VERIFIED_PRINCIPAL,\n        mcp_pb2.DECLARED_PRINCIPAL: ServerState.DECLARED_PRINCIPAL,\n        mcp_pb2.UNVERIFIED_ORIGIN: ServerState.UNVERIFIED_ORIGIN,\n    }\n    state = state_map.get(response.state, ServerState.UNVERIFIED_ORIGIN)\n\n    # Map error code\n    error_code_map = {\n        mcp_pb2.SERVER_ERROR_NONE: ServerErrorCode.NONE,\n        mcp_pb2.SERVER_DID_INVALID: ServerErrorCode.DID_INVALID,\n        mcp_pb2.SERVER_BADGE_INVALID: ServerErrorCode.BADGE_INVALID,\n        mcp_pb2.SERVER_BADGE_EXPIRED: ServerErrorCode.BADGE_EXPIRED,\n        mcp_pb2.SERVER_BADGE_REVOKED: ServerErrorCode.BADGE_REVOKED,\n        mcp_pb2.SERVER_TRUST_INSUFFICIENT: ServerErrorCode.TRUST_INSUFFICIENT,\n        mcp_pb2.SERVER_ORIGIN_MISMATCH: ServerErrorCode.ORIGIN_MISMATCH,\n        mcp_pb2.SERVER_PATH_MISMATCH: ServerErrorCode.PATH_MISMATCH,\n        mcp_pb2.SERVER_ISSUER_UNTRUSTED: ServerErrorCode.ISSUER_UNTRUSTED,\n    }\n    error_code = error_code_map.get(response.error_code, ServerErrorCode.NONE)\n\n    result = VerifyResult(\n        state=state,\n        trust_level=response.trust_level if response.trust_level &gt; 0 else None,\n        server_did=response.server_did or None,\n        badge_jti=response.badge_jti or None,\n        error_code=error_code,\n        error_detail=response.error_detail or None,\n    )\n\n    logger.debug(f\"Server verification result: state={state.value}, trust_level={result.trust_level}\")\n\n    return result\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.verify_server_sync","title":"<code>verify_server_sync(server_did, server_badge=None, transport_origin=None, endpoint_path=None, config=None)</code>","text":"<p>Sync wrapper for verify_server.</p> <p>Parameters:</p> Name Type Description Default <code>server_did</code> <code>Optional[str]</code> <p>Server DID from Capiscio-Server-DID header or _meta</p> required <code>server_badge</code> <code>Optional[str]</code> <p>Server badge JWS from Capiscio-Server-Badge header or _meta</p> <code>None</code> <code>transport_origin</code> <code>Optional[str]</code> <p>HTTP origin (e.g., \"https://mcp.example.com\")</p> <code>None</code> <code>endpoint_path</code> <code>Optional[str]</code> <p>URL path for did:web binding</p> <code>None</code> <code>config</code> <code>Optional[VerifyConfig]</code> <p>Verification configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>VerifyResult</code> <p>VerifyResult with state, trust_level, and any error details</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>def verify_server_sync(\n    server_did: Optional[str],\n    server_badge: Optional[str] = None,\n    transport_origin: Optional[str] = None,\n    endpoint_path: Optional[str] = None,\n    config: Optional[VerifyConfig] = None,\n) -&gt; VerifyResult:\n    \"\"\"\n    Sync wrapper for verify_server.\n\n    Args:\n        server_did: Server DID from Capiscio-Server-DID header or _meta\n        server_badge: Server badge JWS from Capiscio-Server-Badge header or _meta\n        transport_origin: HTTP origin (e.g., \"https://mcp.example.com\")\n        endpoint_path: URL path for did:web binding\n        config: Verification configuration\n\n    Returns:\n        VerifyResult with state, trust_level, and any error details\n    \"\"\"\n    try:\n        loop = asyncio.get_running_loop()\n    except RuntimeError:\n        loop = None\n\n    if loop is not None:\n        import concurrent.futures\n        future = asyncio.run_coroutine_threadsafe(\n            verify_server(server_did, server_badge, transport_origin, endpoint_path, config),\n            loop,\n        )\n        return future.result(timeout=30.0)\n    else:\n        return asyncio.run(\n            verify_server(server_did, server_badge, transport_origin, endpoint_path, config)\n        )\n</code></pre>"},{"location":"api-reference/#guard-module-rfc-006","title":"Guard Module (RFC-006)","text":"<p>RFC-006: MCP Tool Authority Guard.</p> <p>This module provides the @guard decorator for protecting MCP tool execution with identity verification and policy enforcement.</p> <p>Key design principle: params_hash is computed in Python, never sent raw to core. This keeps PII out of the gRPC boundary and avoids cross-language canonicalization.</p> Usage <p>from capiscio_mcp import guard, GuardConfig</p> <p>@guard(min_trust_level=2) async def read_file(path: str) -&gt; str:     ...</p>"},{"location":"api-reference/#capiscio_mcp.guard--with-full-configuration","title":"With full configuration","text":"<p>config = GuardConfig(     min_trust_level=2,     trusted_issuers=[\"did:web:registry.capisc.io\"],     allowed_tools=[\"read_\", \"list_\"], )</p> <p>@guard(config=config) async def execute_query(sql: str) -&gt; list[dict]:     ...</p>"},{"location":"api-reference/#capiscio_mcp.guard.GuardConfig","title":"<code>GuardConfig</code>  <code>dataclass</code>","text":"<p>Configuration for the @guard decorator.</p> <p>Attributes:</p> Name Type Description <code>min_trust_level</code> <code>int</code> <p>Minimum trust level required (0-4, default 0)</p> <code>accept_level_zero</code> <code>bool</code> <p>Accept self-signed (did:key) badges</p> <code>trusted_issuers</code> <code>Optional[List[str]]</code> <p>List of trusted issuer DIDs</p> <code>allowed_tools</code> <code>Optional[List[str]]</code> <p>Glob patterns for allowed tool names</p> <code>policy_version</code> <code>Optional[str]</code> <p>Policy version string for tracking</p> <code>require_badge</code> <code>bool</code> <p>If True, deny anonymous/API key access</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>@dataclass\nclass GuardConfig:\n    \"\"\"\n    Configuration for the @guard decorator.\n\n    Attributes:\n        min_trust_level: Minimum trust level required (0-4, default 0)\n        accept_level_zero: Accept self-signed (did:key) badges\n        trusted_issuers: List of trusted issuer DIDs\n        allowed_tools: Glob patterns for allowed tool names\n        policy_version: Policy version string for tracking\n        require_badge: If True, deny anonymous/API key access\n    \"\"\"\n    min_trust_level: int = 0\n    accept_level_zero: bool = False\n    trusted_issuers: Optional[List[str]] = None\n    allowed_tools: Optional[List[str]] = None\n    policy_version: Optional[str] = None\n    require_badge: bool = False\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration on creation.\"\"\"\n        self.validate()\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate configuration values.\"\"\"\n        if not 0 &lt;= self.min_trust_level &lt;= 4:\n            raise GuardConfigError(\n                f\"min_trust_level must be 0-4, got {self.min_trust_level}\"\n            )\n\n        if self.min_trust_level == 0 and not self.accept_level_zero:\n            # Level 0 is self-signed, must explicitly opt-in\n            pass  # This is fine, will deny Level 0 badges\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.GuardConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate configuration on creation.</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration on creation.\"\"\"\n    self.validate()\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.GuardConfig.validate","title":"<code>validate()</code>","text":"<p>Validate configuration values.</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate configuration values.\"\"\"\n    if not 0 &lt;= self.min_trust_level &lt;= 4:\n        raise GuardConfigError(\n            f\"min_trust_level must be 0-4, got {self.min_trust_level}\"\n        )\n\n    if self.min_trust_level == 0 and not self.accept_level_zero:\n        # Level 0 is self-signed, must explicitly opt-in\n        pass  # This is fine, will deny Level 0 badges\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.GuardResult","title":"<code>GuardResult</code>  <code>dataclass</code>","text":"<p>Result from tool access evaluation.</p> <p>Attributes:</p> Name Type Description <code>decision</code> <code>Decision</code> <p>ALLOW or DENY</p> <code>deny_reason</code> <code>Optional[DenyReason]</code> <p>Reason for denial (if decision is DENY)</p> <code>deny_detail</code> <code>Optional[str]</code> <p>Human-readable detail (if decision is DENY)</p> <code>agent_did</code> <code>Optional[str]</code> <p>Extracted agent DID from credential</p> <code>badge_jti</code> <code>Optional[str]</code> <p>Badge ID if present</p> <code>auth_level</code> <code>AuthLevel</code> <p>Authentication level (ANONYMOUS, API_KEY, BADGE)</p> <code>trust_level</code> <code>int</code> <p>Verified trust level (0-4)</p> <code>evidence_id</code> <code>str</code> <p>Unique evidence record ID</p> <code>evidence_json</code> <code>str</code> <p>RFC-006 \u00a77 compliant JSON</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>@dataclass\nclass GuardResult:\n    \"\"\"\n    Result from tool access evaluation.\n\n    Attributes:\n        decision: ALLOW or DENY\n        deny_reason: Reason for denial (if decision is DENY)\n        deny_detail: Human-readable detail (if decision is DENY)\n        agent_did: Extracted agent DID from credential\n        badge_jti: Badge ID if present\n        auth_level: Authentication level (ANONYMOUS, API_KEY, BADGE)\n        trust_level: Verified trust level (0-4)\n        evidence_id: Unique evidence record ID\n        evidence_json: RFC-006 \u00a77 compliant JSON\n    \"\"\"\n    decision: Decision\n    deny_reason: Optional[DenyReason] = None\n    deny_detail: Optional[str] = None\n\n    # Derived identity\n    agent_did: Optional[str] = None\n    badge_jti: Optional[str] = None\n    auth_level: AuthLevel = AuthLevel.ANONYMOUS\n    trust_level: int = 0\n\n    # Evidence\n    evidence_id: str = \"\"\n    evidence_json: str = \"\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.guard","title":"<code>guard(func=None, *, config=None, min_trust_level=None, tool_name=None, require_badge=False)</code>","text":"<pre><code>guard(func: Callable[P, Coroutine[Any, Any, R]]) -&gt; Callable[P, Coroutine[Any, Any, R]]\n</code></pre><pre><code>guard(*, config: Optional[GuardConfig] = None, min_trust_level: Optional[int] = None, tool_name: Optional[str] = None, require_badge: bool = False) -&gt; Callable[[Callable[P, Coroutine[Any, Any, R]]], Callable[P, Coroutine[Any, Any, R]]]\n</code></pre> <p>Async decorator to guard MCP tool execution.</p> <p>Single RPC call returns decision + evidence atomically.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[P, Coroutine[Any, Any, R]]]</code> <p>Function to decorate (if called without parentheses)</p> <code>None</code> <code>config</code> <code>Optional[GuardConfig]</code> <p>Full configuration object</p> <code>None</code> <code>min_trust_level</code> <code>Optional[int]</code> <p>Shorthand for config.min_trust_level</p> <code>None</code> <code>tool_name</code> <code>Optional[str]</code> <p>Override tool name (default: function name)</p> <code>None</code> <code>require_badge</code> <code>bool</code> <p>If True, deny anonymous/API key access</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Callable[P, Coroutine[Any, Any, R]], Callable[[Callable[P, Coroutine[Any, Any, R]]], Callable[P, Coroutine[Any, Any, R]]]]</code> <p>Decorated function that enforces access control</p> Example Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def guard(\n    func: Optional[Callable[P, Coroutine[Any, Any, R]]] = None,\n    *,\n    config: Optional[GuardConfig] = None,\n    min_trust_level: Optional[int] = None,\n    tool_name: Optional[str] = None,\n    require_badge: bool = False,\n) -&gt; Union[\n    Callable[P, Coroutine[Any, Any, R]],\n    Callable[[Callable[P, Coroutine[Any, Any, R]]], Callable[P, Coroutine[Any, Any, R]]],\n]:\n    \"\"\"\n    Async decorator to guard MCP tool execution.\n\n    Single RPC call returns decision + evidence atomically.\n\n    Args:\n        func: Function to decorate (if called without parentheses)\n        config: Full configuration object\n        min_trust_level: Shorthand for config.min_trust_level\n        tool_name: Override tool name (default: function name)\n        require_badge: If True, deny anonymous/API key access\n\n    Returns:\n        Decorated function that enforces access control\n\n    Example:\n        # Simple usage\n        @guard\n        async def list_files() -&gt; list[str]:\n            ...\n\n        # With trust level requirement\n        @guard(min_trust_level=2)\n        async def execute_query(sql: str) -&gt; list[dict]:\n            ...\n\n        # With full configuration\n        @guard(config=GuardConfig(\n            min_trust_level=2,\n            trusted_issuers=[\"did:web:registry.capisc.io\"],\n        ))\n        async def sensitive_operation(data: dict) -&gt; dict:\n            ...\n    \"\"\"\n    def make_decorator(\n        f: Callable[P, Coroutine[Any, Any, R]]\n    ) -&gt; Callable[P, Coroutine[Any, Any, R]]:\n        # Build effective config\n        effective_config = config or GuardConfig()\n        if min_trust_level is not None:\n            effective_config.min_trust_level = min_trust_level\n        if require_badge:\n            effective_config.require_badge = True\n\n        effective_tool_name = tool_name or f.__name__\n\n        @wraps(f)\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            # Build params dict from kwargs for hashing\n            # Note: args are not included in hash (position-dependent)\n            params = dict(kwargs)\n\n            # Evaluate access\n            result = await evaluate_tool_access(\n                tool_name=effective_tool_name,\n                params=params,\n                config=effective_config,\n            )\n\n            # Check decision\n            if result.decision == Decision.DENY:\n                raise GuardError(\n                    reason=result.deny_reason or DenyReason.INTERNAL_ERROR,\n                    detail=result.deny_detail or \"Access denied\",\n                    evidence_id=result.evidence_id,\n                    agent_did=result.agent_did,\n                    trust_level=result.trust_level,\n                )\n\n            # Log successful access\n            logger.debug(\n                f\"Access allowed for {effective_tool_name}: \"\n                f\"agent={result.agent_did}, trust_level={result.trust_level}\"\n            )\n\n            # Execute tool\n            return await f(*args, **kwargs)\n\n        return wrapper\n\n    # Handle both @guard and @guard() syntax\n    if func is not None:\n        return make_decorator(func)\n    return make_decorator\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.guard--simple-usage","title":"Simple usage","text":"<p>@guard async def list_files() -&gt; list[str]:     ...</p>"},{"location":"api-reference/#capiscio_mcp.guard.guard--with-trust-level-requirement","title":"With trust level requirement","text":"<p>@guard(min_trust_level=2) async def execute_query(sql: str) -&gt; list[dict]:     ...</p>"},{"location":"api-reference/#capiscio_mcp.guard.guard--with-full-configuration","title":"With full configuration","text":"<p>@guard(config=GuardConfig(     min_trust_level=2,     trusted_issuers=[\"did:web:registry.capisc.io\"], )) async def sensitive_operation(data: dict) -&gt; dict:     ...</p>"},{"location":"api-reference/#capiscio_mcp.guard.guard_sync","title":"<code>guard_sync(func=None, *, config=None, min_trust_level=None, tool_name=None, require_badge=False)</code>","text":"<p>Sync decorator to guard MCP tool execution.</p> <p>Same as @guard but for synchronous functions. Internally runs the async guard in an event loop.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[P, R]]</code> <p>Function to decorate (if called without parentheses)</p> <code>None</code> <code>config</code> <code>Optional[GuardConfig]</code> <p>Full configuration object</p> <code>None</code> <code>min_trust_level</code> <code>Optional[int]</code> <p>Shorthand for config.min_trust_level</p> <code>None</code> <code>tool_name</code> <code>Optional[str]</code> <p>Override tool name (default: function name)</p> <code>None</code> <code>require_badge</code> <code>bool</code> <p>If True, deny anonymous/API key access</p> <code>False</code> Example <p>@guard_sync(min_trust_level=2) def read_file(path: str) -&gt; str:     ...</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def guard_sync(\n    func: Optional[Callable[P, R]] = None,\n    *,\n    config: Optional[GuardConfig] = None,\n    min_trust_level: Optional[int] = None,\n    tool_name: Optional[str] = None,\n    require_badge: bool = False,\n) -&gt; Union[Callable[P, R], Callable[[Callable[P, R]], Callable[P, R]]]:\n    \"\"\"\n    Sync decorator to guard MCP tool execution.\n\n    Same as @guard but for synchronous functions.\n    Internally runs the async guard in an event loop.\n\n    Args:\n        func: Function to decorate (if called without parentheses)\n        config: Full configuration object\n        min_trust_level: Shorthand for config.min_trust_level\n        tool_name: Override tool name (default: function name)\n        require_badge: If True, deny anonymous/API key access\n\n    Example:\n        @guard_sync(min_trust_level=2)\n        def read_file(path: str) -&gt; str:\n            ...\n    \"\"\"\n    def make_decorator(f: Callable[P, R]) -&gt; Callable[P, R]:\n        # Build effective config\n        effective_config = config or GuardConfig()\n        if min_trust_level is not None:\n            effective_config.min_trust_level = min_trust_level\n        if require_badge:\n            effective_config.require_badge = True\n\n        effective_tool_name = tool_name or f.__name__\n\n        @wraps(f)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            # Build params dict from kwargs for hashing\n            params = dict(kwargs)\n\n            # Run async evaluation in event loop\n            async def run_eval():\n                return await evaluate_tool_access(\n                    tool_name=effective_tool_name,\n                    params=params,\n                    config=effective_config,\n                )\n\n            try:\n                loop = asyncio.get_running_loop()\n            except RuntimeError:\n                loop = None\n\n            if loop is not None:\n                # We're in an async context, use run_coroutine_threadsafe\n                import concurrent.futures\n                future = asyncio.run_coroutine_threadsafe(run_eval(), loop)\n                result = future.result(timeout=30.0)\n            else:\n                # No event loop, create one\n                result = asyncio.run(run_eval())\n\n            # Check decision\n            if result.decision == Decision.DENY:\n                raise GuardError(\n                    reason=result.deny_reason or DenyReason.INTERNAL_ERROR,\n                    detail=result.deny_detail or \"Access denied\",\n                    evidence_id=result.evidence_id,\n                    agent_did=result.agent_did,\n                    trust_level=result.trust_level,\n                )\n\n            # Execute tool\n            return f(*args, **kwargs)\n\n        return wrapper\n\n    # Handle both @guard_sync and @guard_sync() syntax\n    if func is not None:\n        return make_decorator(func)\n    return make_decorator\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.guard.compute_params_hash","title":"<code>compute_params_hash(params)</code>","text":"<p>Compute deterministic hash of tool parameters.</p> <p>CRITICAL: This stays in Python. Core never sees raw params.</p> <p>Canonicalization rules (JCS-like): 1. Sort keys recursively (lexicographic) 2. Compact JSON (no whitespace) 3. SHA-256 hash 4. Base64url encode (no padding)</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, Any]</code> <p>Tool parameters dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>String in format \"sha256:\" Example <p>compute_params_hash({\"b\": 2, \"a\": 1}) 'sha256:...'  # Same as compute_params_hash({\"a\": 1, \"b\": 2})</p> Source code in <code>capiscio_mcp/guard.py</code> <pre><code>def compute_params_hash(params: dict[str, Any]) -&gt; str:\n    \"\"\"\n    Compute deterministic hash of tool parameters.\n\n    CRITICAL: This stays in Python. Core never sees raw params.\n\n    Canonicalization rules (JCS-like):\n    1. Sort keys recursively (lexicographic)\n    2. Compact JSON (no whitespace)\n    3. SHA-256 hash\n    4. Base64url encode (no padding)\n\n    Args:\n        params: Tool parameters dictionary\n\n    Returns:\n        String in format \"sha256:&lt;base64url&gt;\"\n\n    Example:\n        &gt;&gt;&gt; compute_params_hash({\"b\": 2, \"a\": 1})\n        'sha256:...'  # Same as compute_params_hash({\"a\": 1, \"b\": 2})\n    \"\"\"\n    def sort_recursive(obj: Any) -&gt; Any:\n        if isinstance(obj, dict):\n            return {k: sort_recursive(v) for k, v in sorted(obj.items())}\n        if isinstance(obj, list):\n            return [sort_recursive(item) for item in obj]\n        return obj\n\n    canonical = json.dumps(\n        sort_recursive(params),\n        separators=(\",\", \":\"),\n        ensure_ascii=True,\n    )\n    digest = hashlib.sha256(canonical.encode(\"utf-8\")).digest()\n    b64 = base64.urlsafe_b64encode(digest).rstrip(b\"=\").decode(\"ascii\")\n    return f\"sha256:{b64}\"\n</code></pre>"},{"location":"api-reference/#server-module-rfc-007","title":"Server Module (RFC-007)","text":"<p>RFC-007: MCP Server Identity Verification.</p> <p>This module provides functions to verify MCP server identity before establishing trust with the server.</p> <p>Key distinction from Trust Level 0: - UNVERIFIED_ORIGIN: Server disclosed NO identity material at all - Trust Level 0: Server disclosed a self-signed (did:key) identity</p> Usage <p>from capiscio_mcp import verify_server, ServerState, VerifyConfig</p> <p>result = await verify_server(     server_did=\"did:web:mcp.example.com:servers:filesystem\",     server_badge=\"eyJhbGc...\",     transport_origin=\"https://mcp.example.com\", )</p> <p>if result.state == ServerState.VERIFIED_PRINCIPAL:     print(f\"Server verified at trust level {result.trust_level}\") elif result.state == ServerState.UNVERIFIED_ORIGIN:     print(\"Warning: Server did not disclose identity\")</p>"},{"location":"api-reference/#capiscio_mcp.server.VerifyConfig","title":"<code>VerifyConfig</code>  <code>dataclass</code>","text":"<p>Configuration for server identity verification.</p> <p>Attributes:</p> Name Type Description <code>trusted_issuers</code> <code>Optional[List[str]]</code> <p>List of trusted issuer DIDs</p> <code>min_trust_level</code> <code>int</code> <p>Minimum trust level required (0-4)</p> <code>accept_level_zero</code> <code>bool</code> <p>Accept self-signed (did:key) servers</p> <code>offline_mode</code> <code>bool</code> <p>Skip revocation checks</p> <code>skip_origin_binding</code> <code>bool</code> <p>Skip host/path binding checks (for trusted gateways)</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>@dataclass\nclass VerifyConfig:\n    \"\"\"\n    Configuration for server identity verification.\n\n    Attributes:\n        trusted_issuers: List of trusted issuer DIDs\n        min_trust_level: Minimum trust level required (0-4)\n        accept_level_zero: Accept self-signed (did:key) servers\n        offline_mode: Skip revocation checks\n        skip_origin_binding: Skip host/path binding checks (for trusted gateways)\n    \"\"\"\n    trusted_issuers: Optional[List[str]] = None\n    min_trust_level: int = 0\n    accept_level_zero: bool = False\n    offline_mode: bool = False\n    skip_origin_binding: bool = False\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.VerifyResult","title":"<code>VerifyResult</code>  <code>dataclass</code>","text":"<p>Result of server identity verification.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>ServerState</code> <p>Server classification state (VERIFIED_PRINCIPAL, DECLARED_PRINCIPAL, UNVERIFIED_ORIGIN)</p> <code>trust_level</code> <code>Optional[int]</code> <p>Trust level if verified (0-4)</p> <code>server_did</code> <code>Optional[str]</code> <p>Server DID if disclosed</p> <code>badge_jti</code> <code>Optional[str]</code> <p>Badge ID if present</p> <code>error_code</code> <code>ServerErrorCode</code> <p>Error code if verification failed</p> <code>error_detail</code> <code>Optional[str]</code> <p>Human-readable error detail</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>@dataclass\nclass VerifyResult:\n    \"\"\"\n    Result of server identity verification.\n\n    Attributes:\n        state: Server classification state (VERIFIED_PRINCIPAL, DECLARED_PRINCIPAL, UNVERIFIED_ORIGIN)\n        trust_level: Trust level if verified (0-4)\n        server_did: Server DID if disclosed\n        badge_jti: Badge ID if present\n        error_code: Error code if verification failed\n        error_detail: Human-readable error detail\n    \"\"\"\n    state: ServerState\n    trust_level: Optional[int] = None\n\n    # Derived identity\n    server_did: Optional[str] = None\n    badge_jti: Optional[str] = None\n\n    # Error details\n    error_code: ServerErrorCode = ServerErrorCode.NONE\n    error_detail: Optional[str] = None\n\n    @property\n    def is_verified(self) -&gt; bool:\n        \"\"\"Check if server identity is cryptographically verified.\"\"\"\n        return self.state == ServerState.VERIFIED_PRINCIPAL\n\n    @property\n    def has_identity(self) -&gt; bool:\n        \"\"\"Check if server disclosed any identity.\"\"\"\n        return self.state != ServerState.UNVERIFIED_ORIGIN\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.VerifyResult.has_identity","title":"<code>has_identity</code>  <code>property</code>","text":"<p>Check if server disclosed any identity.</p>"},{"location":"api-reference/#capiscio_mcp.server.VerifyResult.is_verified","title":"<code>is_verified</code>  <code>property</code>","text":"<p>Check if server identity is cryptographically verified.</p>"},{"location":"api-reference/#capiscio_mcp.server.verify_server","title":"<code>verify_server(server_did, server_badge=None, transport_origin=None, endpoint_path=None, config=None)</code>  <code>async</code>","text":"<p>Verify MCP server identity per RFC-007 \u00a77.2.</p> <p>This function implements the client verification algorithm: 1. If no DID disclosed \u2192 UNVERIFIED_ORIGIN 2. If DID but no badge \u2192 DECLARED_PRINCIPAL 3. If DID + badge \u2192 verify badge \u2192 VERIFIED_PRINCIPAL or error</p> <p>Parameters:</p> Name Type Description Default <code>server_did</code> <code>Optional[str]</code> <p>Server DID from Capiscio-Server-DID header or _meta</p> required <code>server_badge</code> <code>Optional[str]</code> <p>Server badge JWS from Capiscio-Server-Badge header or _meta</p> <code>None</code> <code>transport_origin</code> <code>Optional[str]</code> <p>HTTP origin (e.g., \"https://mcp.example.com\")</p> <code>None</code> <code>endpoint_path</code> <code>Optional[str]</code> <p>URL path for did:web binding (e.g., \"/mcp/filesystem\")</p> <code>None</code> <code>config</code> <code>Optional[VerifyConfig]</code> <p>Verification configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>VerifyResult</code> <p>VerifyResult with state, trust_level, and any error details</p> Example <p>result = await verify_server(     server_did=\"did:web:mcp.example.com:servers:filesystem\",     server_badge=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\",     transport_origin=\"https://mcp.example.com\", )</p> <p>match result.state:     case ServerState.VERIFIED_PRINCIPAL:         print(f\"Verified at level {result.trust_level}\")     case ServerState.DECLARED_PRINCIPAL:         print(\"Identity claimed but not verified\")     case ServerState.UNVERIFIED_ORIGIN:         print(\"No identity disclosed\")</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>async def verify_server(\n    server_did: Optional[str],\n    server_badge: Optional[str] = None,\n    transport_origin: Optional[str] = None,\n    endpoint_path: Optional[str] = None,\n    config: Optional[VerifyConfig] = None,\n) -&gt; VerifyResult:\n    \"\"\"\n    Verify MCP server identity per RFC-007 \u00a77.2.\n\n    This function implements the client verification algorithm:\n    1. If no DID disclosed \u2192 UNVERIFIED_ORIGIN\n    2. If DID but no badge \u2192 DECLARED_PRINCIPAL\n    3. If DID + badge \u2192 verify badge \u2192 VERIFIED_PRINCIPAL or error\n\n    Args:\n        server_did: Server DID from Capiscio-Server-DID header or _meta\n        server_badge: Server badge JWS from Capiscio-Server-Badge header or _meta\n        transport_origin: HTTP origin (e.g., \"https://mcp.example.com\")\n        endpoint_path: URL path for did:web binding (e.g., \"/mcp/filesystem\")\n        config: Verification configuration\n\n    Returns:\n        VerifyResult with state, trust_level, and any error details\n\n    Example:\n        result = await verify_server(\n            server_did=\"did:web:mcp.example.com:servers:filesystem\",\n            server_badge=\"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...\",\n            transport_origin=\"https://mcp.example.com\",\n        )\n\n        match result.state:\n            case ServerState.VERIFIED_PRINCIPAL:\n                print(f\"Verified at level {result.trust_level}\")\n            case ServerState.DECLARED_PRINCIPAL:\n                print(\"Identity claimed but not verified\")\n            case ServerState.UNVERIFIED_ORIGIN:\n                print(\"No identity disclosed\")\n    \"\"\"\n    from capiscio_mcp._core.client import CoreClient\n\n    effective_config = config or VerifyConfig()\n\n    # Quick path: no DID disclosed at all\n    if not server_did:\n        logger.debug(\"Server did not disclose identity (UNVERIFIED_ORIGIN)\")\n        return VerifyResult(\n            state=ServerState.UNVERIFIED_ORIGIN,\n            error_code=ServerErrorCode.NONE,\n        )\n\n    # Get core client\n    client = await CoreClient.get_instance()\n\n    # Import proto\n    from capiscio_mcp._proto.capiscio.v1 import mcp_pb2\n\n    # Build request\n    request = mcp_pb2.VerifyServerIdentityRequest(\n        server_did=server_did,\n        server_badge=server_badge or \"\",\n        transport_origin=transport_origin or \"\",\n        endpoint_path=endpoint_path or \"\",\n        config=mcp_pb2.VerifyConfig(\n            trusted_issuers=effective_config.trusted_issuers or [],\n            min_trust_level=effective_config.min_trust_level,\n            accept_level_zero=effective_config.accept_level_zero,\n            offline_mode=effective_config.offline_mode,\n            skip_origin_binding=effective_config.skip_origin_binding,\n        ),\n    )\n\n    # Make RPC call\n    response = await client.stub.VerifyServerIdentity(request)\n\n    # Map response state\n    state_map = {\n        mcp_pb2.VERIFIED_PRINCIPAL: ServerState.VERIFIED_PRINCIPAL,\n        mcp_pb2.DECLARED_PRINCIPAL: ServerState.DECLARED_PRINCIPAL,\n        mcp_pb2.UNVERIFIED_ORIGIN: ServerState.UNVERIFIED_ORIGIN,\n    }\n    state = state_map.get(response.state, ServerState.UNVERIFIED_ORIGIN)\n\n    # Map error code\n    error_code_map = {\n        mcp_pb2.SERVER_ERROR_NONE: ServerErrorCode.NONE,\n        mcp_pb2.SERVER_DID_INVALID: ServerErrorCode.DID_INVALID,\n        mcp_pb2.SERVER_BADGE_INVALID: ServerErrorCode.BADGE_INVALID,\n        mcp_pb2.SERVER_BADGE_EXPIRED: ServerErrorCode.BADGE_EXPIRED,\n        mcp_pb2.SERVER_BADGE_REVOKED: ServerErrorCode.BADGE_REVOKED,\n        mcp_pb2.SERVER_TRUST_INSUFFICIENT: ServerErrorCode.TRUST_INSUFFICIENT,\n        mcp_pb2.SERVER_ORIGIN_MISMATCH: ServerErrorCode.ORIGIN_MISMATCH,\n        mcp_pb2.SERVER_PATH_MISMATCH: ServerErrorCode.PATH_MISMATCH,\n        mcp_pb2.SERVER_ISSUER_UNTRUSTED: ServerErrorCode.ISSUER_UNTRUSTED,\n    }\n    error_code = error_code_map.get(response.error_code, ServerErrorCode.NONE)\n\n    result = VerifyResult(\n        state=state,\n        trust_level=response.trust_level if response.trust_level &gt; 0 else None,\n        server_did=response.server_did or None,\n        badge_jti=response.badge_jti or None,\n        error_code=error_code,\n        error_detail=response.error_detail or None,\n    )\n\n    logger.debug(f\"Server verification result: state={state.value}, trust_level={result.trust_level}\")\n\n    return result\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.verify_server_sync","title":"<code>verify_server_sync(server_did, server_badge=None, transport_origin=None, endpoint_path=None, config=None)</code>","text":"<p>Sync wrapper for verify_server.</p> <p>Parameters:</p> Name Type Description Default <code>server_did</code> <code>Optional[str]</code> <p>Server DID from Capiscio-Server-DID header or _meta</p> required <code>server_badge</code> <code>Optional[str]</code> <p>Server badge JWS from Capiscio-Server-Badge header or _meta</p> <code>None</code> <code>transport_origin</code> <code>Optional[str]</code> <p>HTTP origin (e.g., \"https://mcp.example.com\")</p> <code>None</code> <code>endpoint_path</code> <code>Optional[str]</code> <p>URL path for did:web binding</p> <code>None</code> <code>config</code> <code>Optional[VerifyConfig]</code> <p>Verification configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>VerifyResult</code> <p>VerifyResult with state, trust_level, and any error details</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>def verify_server_sync(\n    server_did: Optional[str],\n    server_badge: Optional[str] = None,\n    transport_origin: Optional[str] = None,\n    endpoint_path: Optional[str] = None,\n    config: Optional[VerifyConfig] = None,\n) -&gt; VerifyResult:\n    \"\"\"\n    Sync wrapper for verify_server.\n\n    Args:\n        server_did: Server DID from Capiscio-Server-DID header or _meta\n        server_badge: Server badge JWS from Capiscio-Server-Badge header or _meta\n        transport_origin: HTTP origin (e.g., \"https://mcp.example.com\")\n        endpoint_path: URL path for did:web binding\n        config: Verification configuration\n\n    Returns:\n        VerifyResult with state, trust_level, and any error details\n    \"\"\"\n    try:\n        loop = asyncio.get_running_loop()\n    except RuntimeError:\n        loop = None\n\n    if loop is not None:\n        import concurrent.futures\n        future = asyncio.run_coroutine_threadsafe(\n            verify_server(server_did, server_badge, transport_origin, endpoint_path, config),\n            loop,\n        )\n        return future.result(timeout=30.0)\n    else:\n        return asyncio.run(\n            verify_server(server_did, server_badge, transport_origin, endpoint_path, config)\n        )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.parse_http_headers","title":"<code>parse_http_headers(headers)</code>","text":"<p>Extract server identity from HTTP response headers.</p> <p>RFC-007 \u00a76.1 specifies these header names: - Capiscio-Server-DID: Server's DID - Capiscio-Server-Badge: Server's badge (JWS)</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>Dict[str, str]</code> <p>HTTP response headers dict (case-insensitive lookup)</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str]]</code> <p>Tuple of (server_did, server_badge)</p> Example <p>did, badge = parse_http_headers(response.headers) result = await verify_server(did, badge)</p> Source code in <code>capiscio_mcp/server.py</code> <pre><code>def parse_http_headers(headers: Dict[str, str]) -&gt; Tuple[Optional[str], Optional[str]]:\n    \"\"\"\n    Extract server identity from HTTP response headers.\n\n    RFC-007 \u00a76.1 specifies these header names:\n    - Capiscio-Server-DID: Server's DID\n    - Capiscio-Server-Badge: Server's badge (JWS)\n\n    Args:\n        headers: HTTP response headers dict (case-insensitive lookup)\n\n    Returns:\n        Tuple of (server_did, server_badge)\n\n    Example:\n        did, badge = parse_http_headers(response.headers)\n        result = await verify_server(did, badge)\n    \"\"\"\n    # Try exact case first, then case-insensitive\n    def get_header(name: str) -&gt; Optional[str]:\n        if name in headers:\n            return headers[name]\n        # Case-insensitive lookup\n        lower_name = name.lower()\n        for key, value in headers.items():\n            if key.lower() == lower_name:\n                return value\n        return None\n\n    return (\n        get_header(\"Capiscio-Server-DID\"),\n        get_header(\"Capiscio-Server-Badge\"),\n    )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.parse_jsonrpc_meta","title":"<code>parse_jsonrpc_meta(meta)</code>","text":"<p>Extract server identity from MCP initialize response _meta.</p> <p>RFC-007 \u00a76.2 specifies these _meta keys: - capiscio_server_did: Server's DID - capiscio_server_badge: Server's badge (JWS)</p> <p>For PoP fields, use pop.PoPRequest.from_meta() and pop.PoPResponse.from_meta().</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Optional[Dict[str, Any]]</code> <p>The _meta object from InitializeResult</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str]]</code> <p>Tuple of (server_did, server_badge)</p> Example Source code in <code>capiscio_mcp/server.py</code> <pre><code>def parse_jsonrpc_meta(meta: Optional[Dict[str, Any]]) -&gt; Tuple[Optional[str], Optional[str]]:\n    \"\"\"\n    Extract server identity from MCP initialize response _meta.\n\n    RFC-007 \u00a76.2 specifies these _meta keys:\n    - capiscio_server_did: Server's DID\n    - capiscio_server_badge: Server's badge (JWS)\n\n    For PoP fields, use pop.PoPRequest.from_meta() and pop.PoPResponse.from_meta().\n\n    Args:\n        meta: The _meta object from InitializeResult\n\n    Returns:\n        Tuple of (server_did, server_badge)\n\n    Example:\n        # In MCP client initialization\n        result = await client.initialize()\n        did, badge = parse_jsonrpc_meta(result.meta)\n        verify_result = await verify_server(did, badge)\n\n        # For PoP verification\n        from capiscio_mcp.pop import PoPResponse, verify_pop_response\n        pop_response = PoPResponse.from_meta(result.meta)\n    \"\"\"\n    if meta is None:\n        return (None, None)\n\n    return (\n        meta.get(\"capiscio_server_did\"),\n        meta.get(\"capiscio_server_badge\"),\n    )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.server.parse_jsonrpc_meta--in-mcp-client-initialization","title":"In MCP client initialization","text":"<p>result = await client.initialize() did, badge = parse_jsonrpc_meta(result.meta) verify_result = await verify_server(did, badge)</p>"},{"location":"api-reference/#capiscio_mcp.server.parse_jsonrpc_meta--for-pop-verification","title":"For PoP verification","text":"<p>from capiscio_mcp.pop import PoPResponse, verify_pop_response pop_response = PoPResponse.from_meta(result.meta)</p>"},{"location":"api-reference/#pop-module-key-verification","title":"PoP Module (Key Verification)","text":"<p>Proof of Possession (PoP) primitives for RFC-007 MCP server identity.</p> <p>This module implements the PoP handshake for MCP server identity verification: 1. Client generates a nonce and includes it in initialize request _meta 2. Server signs the nonce with its DID key and returns signature in response _meta 3. Client verifies the signature to prove server controls the DID key</p> <p>The PoP handshake upgrades server state from DECLARED_PRINCIPAL to VERIFIED_PRINCIPAL.</p> <p>Usage (Client):     # Generate PoP request     pop_request = generate_pop_request()</p> <pre><code># Include in initialize request _meta\nmeta = {\n    **pop_request.to_meta(),\n    \"capiscio_server_did\": server_did,  # If available\n}\n\n# After receiving response, verify PoP\npop_response = PoPResponse.from_meta(response._meta)\nif pop_response:\n    verify_pop_response(pop_request, pop_response, server_public_key)\n</code></pre> <p>Usage (Server):     # Parse PoP request from client     pop_request = PoPRequest.from_meta(request._meta)</p> <pre><code># Create signed response\nif pop_request and private_key:\n    pop_response = create_pop_response(pop_request, private_key, key_id)\n\n    # Include in initialize response _meta\n    meta = {\n        **identity_meta,\n        **pop_response.to_meta(),\n    }\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPRequest","title":"<code>PoPRequest</code>  <code>dataclass</code>","text":"<p>PoP request sent by client in initialize request _meta.</p> <p>Per RFC-007, the client generates a random nonce and includes it in the initialize request. The server must sign this nonce to prove possession of the DID key.</p> <p>Attributes:</p> Name Type Description <code>client_nonce</code> <code>str</code> <p>Base64url-encoded random nonce (32 bytes)</p> <code>created_at</code> <code>float</code> <p>Timestamp when nonce was generated</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>@dataclass\nclass PoPRequest:\n    \"\"\"\n    PoP request sent by client in initialize request _meta.\n\n    Per RFC-007, the client generates a random nonce and includes it\n    in the initialize request. The server must sign this nonce to\n    prove possession of the DID key.\n\n    Attributes:\n        client_nonce: Base64url-encoded random nonce (32 bytes)\n        created_at: Timestamp when nonce was generated\n    \"\"\"\n    client_nonce: str\n    created_at: float  # Unix timestamp\n\n    def to_meta(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert to _meta format for MCP initialize request.\n\n        Returns:\n            Dict with capiscio_pop_nonce and capiscio_pop_created_at\n        \"\"\"\n        return {\n            \"capiscio_pop_nonce\": self.client_nonce,\n            \"capiscio_pop_created_at\": int(self.created_at),\n        }\n\n    @classmethod\n    def from_meta(cls, meta: Optional[Dict[str, Any]]) -&gt; Optional[\"PoPRequest\"]:\n        \"\"\"\n        Parse PoP request from MCP _meta object.\n\n        Args:\n            meta: The _meta dict from initialize request\n\n        Returns:\n            PoPRequest if present, None otherwise\n        \"\"\"\n        if not meta:\n            return None\n\n        nonce = meta.get(\"capiscio_pop_nonce\")\n        if not nonce or not isinstance(nonce, str):\n            return None\n\n        # Parse created_at with fallback to current time\n        created_at = meta.get(\"capiscio_pop_created_at\")\n        if isinstance(created_at, (int, float)):\n            ts = float(created_at)\n        else:\n            ts = time.time()\n\n        return cls(client_nonce=nonce, created_at=ts)\n\n    def is_expired(self, max_age: float = POP_MAX_AGE_SECONDS) -&gt; bool:\n        \"\"\"Check if the PoP request has expired.\"\"\"\n        return (time.time() - self.created_at) &gt; max_age\n\n    @property\n    def created_datetime(self) -&gt; datetime:\n        \"\"\"Get created_at as datetime.\"\"\"\n        return datetime.fromtimestamp(self.created_at)\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPRequest.created_datetime","title":"<code>created_datetime</code>  <code>property</code>","text":"<p>Get created_at as datetime.</p>"},{"location":"api-reference/#capiscio_mcp.pop.PoPRequest.from_meta","title":"<code>from_meta(meta)</code>  <code>classmethod</code>","text":"<p>Parse PoP request from MCP _meta object.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Optional[Dict[str, Any]]</code> <p>The _meta dict from initialize request</p> required <p>Returns:</p> Type Description <code>Optional['PoPRequest']</code> <p>PoPRequest if present, None otherwise</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>@classmethod\ndef from_meta(cls, meta: Optional[Dict[str, Any]]) -&gt; Optional[\"PoPRequest\"]:\n    \"\"\"\n    Parse PoP request from MCP _meta object.\n\n    Args:\n        meta: The _meta dict from initialize request\n\n    Returns:\n        PoPRequest if present, None otherwise\n    \"\"\"\n    if not meta:\n        return None\n\n    nonce = meta.get(\"capiscio_pop_nonce\")\n    if not nonce or not isinstance(nonce, str):\n        return None\n\n    # Parse created_at with fallback to current time\n    created_at = meta.get(\"capiscio_pop_created_at\")\n    if isinstance(created_at, (int, float)):\n        ts = float(created_at)\n    else:\n        ts = time.time()\n\n    return cls(client_nonce=nonce, created_at=ts)\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPRequest.is_expired","title":"<code>is_expired(max_age=POP_MAX_AGE_SECONDS)</code>","text":"<p>Check if the PoP request has expired.</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def is_expired(self, max_age: float = POP_MAX_AGE_SECONDS) -&gt; bool:\n    \"\"\"Check if the PoP request has expired.\"\"\"\n    return (time.time() - self.created_at) &gt; max_age\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPRequest.to_meta","title":"<code>to_meta()</code>","text":"<p>Convert to _meta format for MCP initialize request.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with capiscio_pop_nonce and capiscio_pop_created_at</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def to_meta(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert to _meta format for MCP initialize request.\n\n    Returns:\n        Dict with capiscio_pop_nonce and capiscio_pop_created_at\n    \"\"\"\n    return {\n        \"capiscio_pop_nonce\": self.client_nonce,\n        \"capiscio_pop_created_at\": int(self.created_at),\n    }\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPResponse","title":"<code>PoPResponse</code>  <code>dataclass</code>","text":"<p>PoP response sent by server in initialize response _meta.</p> <p>Per RFC-007, the server signs the client's nonce with its DID key and returns the signature. The client verifies this signature to prove the server controls the private key for the disclosed DID.</p> <p>Attributes:</p> Name Type Description <code>nonce_signature</code> <code>str</code> <p>JWS compact serialization of signed nonce</p> <code>signed_at</code> <code>float</code> <p>Timestamp when signature was created</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>@dataclass\nclass PoPResponse:\n    \"\"\"\n    PoP response sent by server in initialize response _meta.\n\n    Per RFC-007, the server signs the client's nonce with its DID key\n    and returns the signature. The client verifies this signature to\n    prove the server controls the private key for the disclosed DID.\n\n    Attributes:\n        nonce_signature: JWS compact serialization of signed nonce\n        signed_at: Timestamp when signature was created\n    \"\"\"\n    nonce_signature: str\n    signed_at: float  # Unix timestamp\n\n    def to_meta(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert to _meta format for MCP initialize response.\n\n        Returns:\n            Dict with capiscio_pop_signature and capiscio_pop_signed_at\n        \"\"\"\n        return {\n            \"capiscio_pop_signature\": self.nonce_signature,\n            \"capiscio_pop_signed_at\": int(self.signed_at),\n        }\n\n    @classmethod\n    def from_meta(cls, meta: Optional[Dict[str, Any]]) -&gt; Optional[\"PoPResponse\"]:\n        \"\"\"\n        Parse PoP response from MCP _meta object.\n\n        Args:\n            meta: The _meta dict from initialize response\n\n        Returns:\n            PoPResponse if present, None otherwise\n        \"\"\"\n        if not meta:\n            return None\n\n        signature = meta.get(\"capiscio_pop_signature\")\n        if not signature or not isinstance(signature, str):\n            return None\n\n        # Parse signed_at with fallback to current time\n        signed_at = meta.get(\"capiscio_pop_signed_at\")\n        if isinstance(signed_at, (int, float)):\n            ts = float(signed_at)\n        else:\n            ts = time.time()\n\n        return cls(nonce_signature=signature, signed_at=ts)\n\n    @property\n    def signed_datetime(self) -&gt; datetime:\n        \"\"\"Get signed_at as datetime.\"\"\"\n        return datetime.fromtimestamp(self.signed_at)\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPResponse.signed_datetime","title":"<code>signed_datetime</code>  <code>property</code>","text":"<p>Get signed_at as datetime.</p>"},{"location":"api-reference/#capiscio_mcp.pop.PoPResponse.from_meta","title":"<code>from_meta(meta)</code>  <code>classmethod</code>","text":"<p>Parse PoP response from MCP _meta object.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Optional[Dict[str, Any]]</code> <p>The _meta dict from initialize response</p> required <p>Returns:</p> Type Description <code>Optional['PoPResponse']</code> <p>PoPResponse if present, None otherwise</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>@classmethod\ndef from_meta(cls, meta: Optional[Dict[str, Any]]) -&gt; Optional[\"PoPResponse\"]:\n    \"\"\"\n    Parse PoP response from MCP _meta object.\n\n    Args:\n        meta: The _meta dict from initialize response\n\n    Returns:\n        PoPResponse if present, None otherwise\n    \"\"\"\n    if not meta:\n        return None\n\n    signature = meta.get(\"capiscio_pop_signature\")\n    if not signature or not isinstance(signature, str):\n        return None\n\n    # Parse signed_at with fallback to current time\n    signed_at = meta.get(\"capiscio_pop_signed_at\")\n    if isinstance(signed_at, (int, float)):\n        ts = float(signed_at)\n    else:\n        ts = time.time()\n\n    return cls(nonce_signature=signature, signed_at=ts)\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPResponse.to_meta","title":"<code>to_meta()</code>","text":"<p>Convert to _meta format for MCP initialize response.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with capiscio_pop_signature and capiscio_pop_signed_at</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def to_meta(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert to _meta format for MCP initialize response.\n\n    Returns:\n        Dict with capiscio_pop_signature and capiscio_pop_signed_at\n    \"\"\"\n    return {\n        \"capiscio_pop_signature\": self.nonce_signature,\n        \"capiscio_pop_signed_at\": int(self.signed_at),\n    }\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPError","title":"<code>PoPError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for PoP errors.</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>class PoPError(Exception):\n    \"\"\"Base exception for PoP errors.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPSignatureError","title":"<code>PoPSignatureError</code>","text":"<p>               Bases: <code>PoPError</code></p> <p>Error signing or verifying PoP.</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>class PoPSignatureError(PoPError):\n    \"\"\"Error signing or verifying PoP.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.PoPExpiredError","title":"<code>PoPExpiredError</code>","text":"<p>               Bases: <code>PoPError</code></p> <p>PoP request has expired.</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>class PoPExpiredError(PoPError):\n    \"\"\"PoP request has expired.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.generate_pop_request","title":"<code>generate_pop_request()</code>","text":"<p>Generate a new PoP request for MCP initialize.</p> <p>Creates a request with a fresh nonce and current timestamp.</p> <p>Returns:</p> Type Description <code>PoPRequest</code> <p>PoPRequest ready to include in _meta</p> <p>Raises:</p> Type Description <code>PoPNonceError</code> <p>If nonce generation fails</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def generate_pop_request() -&gt; PoPRequest:\n    \"\"\"\n    Generate a new PoP request for MCP initialize.\n\n    Creates a request with a fresh nonce and current timestamp.\n\n    Returns:\n        PoPRequest ready to include in _meta\n\n    Raises:\n        PoPNonceError: If nonce generation fails\n    \"\"\"\n    return PoPRequest(\n        client_nonce=generate_nonce(),\n        created_at=time.time(),\n    )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.create_pop_response","title":"<code>create_pop_response(request, private_key, key_id)</code>","text":"<p>Create a PoP response by signing the client's nonce.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PoPRequest</code> <p>The PoP request containing client nonce</p> required <code>private_key</code> <code>'Ed25519PrivateKey'</code> <p>Server's Ed25519 private key</p> required <code>key_id</code> <code>str</code> <p>Key ID for JWS header (e.g., DID key reference)</p> required <p>Returns:</p> Type Description <code>PoPResponse</code> <p>PoPResponse ready to include in _meta</p> <p>Raises:</p> Type Description <code>PoPMissingCrypto</code> <p>If cryptography package not available</p> <code>PoPSignatureError</code> <p>If signing fails</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def create_pop_response(\n    request: PoPRequest,\n    private_key: \"Ed25519PrivateKey\",\n    key_id: str,\n) -&gt; PoPResponse:\n    \"\"\"\n    Create a PoP response by signing the client's nonce.\n\n    Args:\n        request: The PoP request containing client nonce\n        private_key: Server's Ed25519 private key\n        key_id: Key ID for JWS header (e.g., DID key reference)\n\n    Returns:\n        PoPResponse ready to include in _meta\n\n    Raises:\n        PoPMissingCrypto: If cryptography package not available\n        PoPSignatureError: If signing fails\n    \"\"\"\n    signature = sign_nonce(request.client_nonce, private_key, key_id)\n    return PoPResponse(\n        nonce_signature=signature,\n        signed_at=time.time(),\n    )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.pop.verify_pop_response","title":"<code>verify_pop_response(request, response, public_key, max_age=POP_MAX_AGE_SECONDS)</code>","text":"<p>Verify a complete PoP response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PoPRequest</code> <p>The original PoP request</p> required <code>response</code> <code>PoPResponse</code> <p>The PoP response from server</p> required <code>public_key</code> <code>'Ed25519PublicKey'</code> <p>Server's Ed25519 public key</p> required <code>max_age</code> <code>float</code> <p>Maximum age of request in seconds</p> <code>POP_MAX_AGE_SECONDS</code> <p>Raises:</p> Type Description <code>PoPMissingCrypto</code> <p>If cryptography package not available</p> <code>PoPExpiredError</code> <p>If request has expired</p> <code>PoPSignatureError</code> <p>If signature verification fails</p> Source code in <code>capiscio_mcp/pop.py</code> <pre><code>def verify_pop_response(\n    request: PoPRequest,\n    response: PoPResponse,\n    public_key: \"Ed25519PublicKey\",\n    max_age: float = POP_MAX_AGE_SECONDS,\n) -&gt; None:\n    \"\"\"\n    Verify a complete PoP response.\n\n    Args:\n        request: The original PoP request\n        response: The PoP response from server\n        public_key: Server's Ed25519 public key\n        max_age: Maximum age of request in seconds\n\n    Raises:\n        PoPMissingCrypto: If cryptography package not available\n        PoPExpiredError: If request has expired\n        PoPSignatureError: If signature verification fails\n    \"\"\"\n    # Check expiry\n    if request.is_expired(max_age):\n        raise PoPExpiredError(\n            f\"PoP request expired (age: {time.time() - request.created_at:.1f}s, \"\n            f\"max: {max_age}s)\"\n        )\n\n    # Verify signature\n    verify_pop_signature(\n        jws=response.nonce_signature,\n        expected_nonce=request.client_nonce,\n        public_key=public_key,\n    )\n</code></pre>"},{"location":"api-reference/#types","title":"Types","text":"<p>Type definitions for capiscio-mcp.</p> <p>Defines enums and dataclasses used across the package for: - RFC-006: Tool authority decisions and deny reasons - RFC-007: Server identity states and error codes</p>"},{"location":"api-reference/#capiscio_mcp.types.Decision","title":"<code>Decision</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Tool access decision result.</p> <p>Per RFC-006 \u00a76.3, every tool invocation attempt results in one of: - ALLOW: Tool execution is permitted - DENY: Tool execution is blocked with a reason</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class Decision(str, Enum):\n    \"\"\"\n    Tool access decision result.\n\n    Per RFC-006 \u00a76.3, every tool invocation attempt results in one of:\n    - ALLOW: Tool execution is permitted\n    - DENY: Tool execution is blocked with a reason\n    \"\"\"\n    ALLOW = \"allow\"\n    DENY = \"deny\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.AuthLevel","title":"<code>AuthLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Caller authentication assurance level.</p> <p>Per RFC-006 \u00a75, every evidence log records the authentication method: - ANONYMOUS: No identity material provided - API_KEY: API key authentication (reduced assurance) - BADGE: CapiscIO Trust Badge authentication (full assurance)</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class AuthLevel(str, Enum):\n    \"\"\"\n    Caller authentication assurance level.\n\n    Per RFC-006 \u00a75, every evidence log records the authentication method:\n    - ANONYMOUS: No identity material provided\n    - API_KEY: API key authentication (reduced assurance)\n    - BADGE: CapiscIO Trust Badge authentication (full assurance)\n    \"\"\"\n    ANONYMOUS = \"anonymous\"\n    API_KEY = \"api_key\"\n    BADGE = \"badge\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.DenyReason","title":"<code>DenyReason</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Reason for denying tool access.</p> <p>Per RFC-006 \u00a76.4, denial must include a specific reason code.</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class DenyReason(str, Enum):\n    \"\"\"\n    Reason for denying tool access.\n\n    Per RFC-006 \u00a76.4, denial must include a specific reason code.\n    \"\"\"\n    # Badge issues\n    BADGE_MISSING = \"badge_missing\"           # Required but not provided\n    BADGE_INVALID = \"badge_invalid\"           # Malformed or unverifiable\n    BADGE_EXPIRED = \"badge_expired\"           # Past expiration time\n    BADGE_REVOKED = \"badge_revoked\"           # On revocation list\n\n    # Trust issues\n    TRUST_INSUFFICIENT = \"trust_insufficient\" # Trust level &lt; min required\n    ISSUER_UNTRUSTED = \"issuer_untrusted\"     # Issuer not in trusted list\n\n    # Policy issues\n    TOOL_NOT_ALLOWED = \"tool_not_allowed\"     # Tool not in allowed list\n    POLICY_DENIED = \"policy_denied\"           # Policy evaluation failed\n\n    # Other\n    INTERNAL_ERROR = \"internal_error\"         # Unexpected error\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.ServerState","title":"<code>ServerState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Server identity verification state.</p> <p>Per RFC-007 \u00a75.2, clients classify servers into three states:</p> <ul> <li> <p>VERIFIED_PRINCIPAL: Server badge verified, trust level established.   The server has disclosed a DID and a valid badge signed by a trusted issuer.</p> </li> <li> <p>DECLARED_PRINCIPAL: Server DID disclosed but badge missing or invalid.   Identity is claimed but not cryptographically verified.</p> </li> <li> <p>UNVERIFIED_ORIGIN: Server did not disclose any identity material.   This is distinct from Trust Level 0 (self-signed) - UNVERIFIED_ORIGIN   means NO identity was disclosed at all.</p> </li> </ul> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class ServerState(str, Enum):\n    \"\"\"\n    Server identity verification state.\n\n    Per RFC-007 \u00a75.2, clients classify servers into three states:\n\n    - VERIFIED_PRINCIPAL: Server badge verified, trust level established.\n      The server has disclosed a DID and a valid badge signed by a trusted issuer.\n\n    - DECLARED_PRINCIPAL: Server DID disclosed but badge missing or invalid.\n      Identity is claimed but not cryptographically verified.\n\n    - UNVERIFIED_ORIGIN: Server did not disclose any identity material.\n      This is distinct from Trust Level 0 (self-signed) - UNVERIFIED_ORIGIN\n      means NO identity was disclosed at all.\n    \"\"\"\n    VERIFIED_PRINCIPAL = \"verified_principal\"\n    DECLARED_PRINCIPAL = \"declared_principal\"\n    UNVERIFIED_ORIGIN = \"unverified_origin\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.ServerErrorCode","title":"<code>ServerErrorCode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Server identity verification error codes.</p> <p>Per RFC-007 \u00a78, verification failures include specific error codes.</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class ServerErrorCode(str, Enum):\n    \"\"\"\n    Server identity verification error codes.\n\n    Per RFC-007 \u00a78, verification failures include specific error codes.\n    \"\"\"\n    NONE = \"none\"\n    DID_INVALID = \"did_invalid\"\n    BADGE_INVALID = \"badge_invalid\"\n    BADGE_EXPIRED = \"badge_expired\"\n    BADGE_REVOKED = \"badge_revoked\"\n    TRUST_INSUFFICIENT = \"trust_insufficient\"\n    ORIGIN_MISMATCH = \"origin_mismatch\"\n    PATH_MISMATCH = \"path_mismatch\"\n    ISSUER_UNTRUSTED = \"issuer_untrusted\"\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.TrustLevel","title":"<code>TrustLevel</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Trust levels per RFC-002.</p> <ul> <li>LEVEL_0: Self-signed (did:key issuer)</li> <li>LEVEL_1: Domain Validated (DV)</li> <li>LEVEL_2: Organization Validated (OV)</li> <li>LEVEL_3: Extended Validation (EV)</li> <li>LEVEL_4: Continuous Validation (CV)</li> </ul> Source code in <code>capiscio_mcp/types.py</code> <pre><code>class TrustLevel(IntEnum):\n    \"\"\"\n    Trust levels per RFC-002.\n\n    - LEVEL_0: Self-signed (did:key issuer)\n    - LEVEL_1: Domain Validated (DV)\n    - LEVEL_2: Organization Validated (OV)\n    - LEVEL_3: Extended Validation (EV)\n    - LEVEL_4: Continuous Validation (CV)\n    \"\"\"\n    LEVEL_0 = 0  # Self-signed\n    LEVEL_1 = 1  # DV\n    LEVEL_2 = 2  # OV\n    LEVEL_3 = 3  # EV\n    LEVEL_4 = 4  # CV\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.CallerCredential","title":"<code>CallerCredential</code>  <code>dataclass</code>","text":"<p>Caller credential for tool access evaluation.</p> <p>Only one of badge_jws or api_key should be set. If neither is set, the caller is treated as anonymous.</p> Source code in <code>capiscio_mcp/types.py</code> <pre><code>@dataclass\nclass CallerCredential:\n    \"\"\"\n    Caller credential for tool access evaluation.\n\n    Only one of badge_jws or api_key should be set.\n    If neither is set, the caller is treated as anonymous.\n    \"\"\"\n    badge_jws: Optional[str] = None\n    api_key: Optional[str] = None\n\n    @property\n    def auth_level(self) -&gt; AuthLevel:\n        \"\"\"Derive authentication level from credential type.\"\"\"\n        if self.badge_jws:\n            return AuthLevel.BADGE\n        elif self.api_key:\n            return AuthLevel.API_KEY\n        return AuthLevel.ANONYMOUS\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.types.CallerCredential.auth_level","title":"<code>auth_level</code>  <code>property</code>","text":"<p>Derive authentication level from credential type.</p>"},{"location":"api-reference/#errors","title":"Errors","text":"<p>Exception types for capiscio-mcp.</p> <p>Provides typed exceptions for: - Guard (RFC-006) errors - Server verification (RFC-007) errors - Core connection errors</p>"},{"location":"api-reference/#capiscio_mcp.errors.GuardError","title":"<code>GuardError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when tool access is denied by the guard.</p> <p>Per RFC-006, all denials include: - reason: Specific denial reason code - detail: Human-readable explanation - evidence_id: ID of the evidence record for audit</p> Example <p>try:     result = await guarded_tool(params) except GuardError as e:     logger.warning(f\"Access denied: {e.reason} - {e.detail}\")     logger.info(f\"Evidence ID: {e.evidence_id}\")</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class GuardError(CapiscioMCPError):\n    \"\"\"\n    Raised when tool access is denied by the guard.\n\n    Per RFC-006, all denials include:\n    - reason: Specific denial reason code\n    - detail: Human-readable explanation\n    - evidence_id: ID of the evidence record for audit\n\n    Example:\n        try:\n            result = await guarded_tool(params)\n        except GuardError as e:\n            logger.warning(f\"Access denied: {e.reason} - {e.detail}\")\n            logger.info(f\"Evidence ID: {e.evidence_id}\")\n    \"\"\"\n\n    def __init__(\n        self,\n        reason: \"DenyReason\",\n        detail: str,\n        evidence_id: str = \"\",\n        agent_did: Optional[str] = None,\n        trust_level: Optional[int] = None,\n    ):\n        self.reason = reason\n        self.detail = detail\n        self.evidence_id = evidence_id\n        self.agent_did = agent_did\n        self.trust_level = trust_level\n\n        message = f\"{reason.value}: {detail}\"\n        if evidence_id:\n            message += f\" (evidence_id={evidence_id})\"\n\n        super().__init__(message)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"GuardError(reason={self.reason!r}, detail={self.detail!r}, \"\n            f\"evidence_id={self.evidence_id!r})\"\n        )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.errors.GuardConfigError","title":"<code>GuardConfigError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when guard configuration is invalid.</p> <p>This includes: - Invalid trust level values - Invalid tool name patterns - Conflicting configuration options</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class GuardConfigError(CapiscioMCPError):\n    \"\"\"\n    Raised when guard configuration is invalid.\n\n    This includes:\n    - Invalid trust level values\n    - Invalid tool name patterns\n    - Conflicting configuration options\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.errors.ServerVerifyError","title":"<code>ServerVerifyError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when server identity verification fails.</p> <p>Per RFC-007, verification can fail for various reasons including: - Invalid DID format - Badge verification failure - Origin/path binding mismatch - Trust level insufficient</p> Example <p>try:     result = await verify_server(server_did, server_badge) except ServerVerifyError as e:     logger.warning(f\"Server verification failed: {e.error_code}\")     if e.state == ServerState.UNVERIFIED_ORIGIN:         logger.warning(\"Server did not disclose identity\")</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class ServerVerifyError(CapiscioMCPError):\n    \"\"\"\n    Raised when server identity verification fails.\n\n    Per RFC-007, verification can fail for various reasons including:\n    - Invalid DID format\n    - Badge verification failure\n    - Origin/path binding mismatch\n    - Trust level insufficient\n\n    Example:\n        try:\n            result = await verify_server(server_did, server_badge)\n        except ServerVerifyError as e:\n            logger.warning(f\"Server verification failed: {e.error_code}\")\n            if e.state == ServerState.UNVERIFIED_ORIGIN:\n                logger.warning(\"Server did not disclose identity\")\n    \"\"\"\n\n    def __init__(\n        self,\n        error_code: \"ServerErrorCode\",\n        detail: str,\n        state: Optional[\"ServerState\"] = None,\n        server_did: Optional[str] = None,\n    ):\n        self.error_code = error_code\n        self.detail = detail\n        self.state = state\n        self.server_did = server_did\n\n        message = f\"{error_code.value}: {detail}\"\n        super().__init__(message)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"ServerVerifyError(error_code={self.error_code!r}, \"\n            f\"detail={self.detail!r}, state={self.state!r})\"\n        )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.errors.CoreConnectionError","title":"<code>CoreConnectionError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when connection to capiscio-core fails.</p> <p>This includes: - Binary download failures - Process startup failures - gRPC connection failures - Health check failures</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class CoreConnectionError(CapiscioMCPError):\n    \"\"\"\n    Raised when connection to capiscio-core fails.\n\n    This includes:\n    - Binary download failures\n    - Process startup failures\n    - gRPC connection failures\n    - Health check failures\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.errors.CoreVersionError","title":"<code>CoreVersionError</code>","text":"<p>               Bases: <code>CapiscioMCPError</code></p> <p>Raised when capiscio-core version is incompatible.</p> <p>capiscio-mcp requires a specific range of capiscio-core versions. This error indicates the connected core is outside that range.</p> Source code in <code>capiscio_mcp/errors.py</code> <pre><code>class CoreVersionError(CapiscioMCPError):\n    \"\"\"\n    Raised when capiscio-core version is incompatible.\n\n    capiscio-mcp requires a specific range of capiscio-core versions.\n    This error indicates the connected core is outside that range.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#mcp-sdk-integration","title":"MCP SDK Integration","text":"<p>MCP SDK Integration \u2014 requires <code>pip install capiscio-mcp[mcp]</code></p> <p>Provides two separate integration classes: 1. Server-side: CapiscioMCPServer (guard tools, disclose identity, PoP signing) 2. Client-side: CapiscioMCPClient (verify server identity, PoP verification)</p> <p>Usage (Server):     from capiscio_mcp.integrations.mcp import CapiscioMCPServer</p> <pre><code>server = CapiscioMCPServer(\n    name=\"filesystem\",\n    did=\"did:web:mcp.example.com:servers:filesystem\",\n    badge=\"eyJhbGc...\",\n    private_key_path=\"/path/to/key.pem\",  # For PoP signing\n)\n\n@server.tool(min_trust_level=2)\nasync def read_file(path: str) -&gt; str:\n    with open(path) as f:\n        return f.read()\n</code></pre> <p>Usage (Client):     from capiscio_mcp.integrations.mcp import CapiscioMCPClient</p> <pre><code>async with CapiscioMCPClient(\n    server_url=\"https://mcp.example.com\",\n    min_trust_level=2,\n    require_pop=True,  # Require PoP verification\n) as client:\n    result = await client.call_tool(\"read_file\", {\"path\": \"/data/file.txt\"})\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient","title":"<code>CapiscioMCPClient</code>","text":"<p>MCP Client with automatic server identity and PoP verification.</p> <p>This class wraps MCP client functionality to: 1. Generate PoP request (nonce) for initialize request 2. Verify server identity and PoP response on connection 3. Enforce trust level requirements 4. Include caller credentials in tool requests</p> <p>Attributes:</p> Name Type Description <code>server_url</code> <p>URL of the MCP server</p> <code>min_trust_level</code> <p>Minimum required trust level</p> <code>fail_on_unverified</code> <p>If True, raise on unverified servers</p> <code>require_pop</code> <p>If True, require PoP verification (did:key servers)</p> <code>pop_verified</code> <code>bool</code> <p>Whether PoP verification succeeded</p> Example <p>async with CapiscioMCPClient(     server_url=\"https://mcp.example.com\",     min_trust_level=2,     require_pop=True,     badge=\"eyJhbGc...\",  # Your client badge ) as client:     # Server identity and PoP already verified     print(f\"Trusted at level {client.server_trust_level}\")     print(f\"PoP verified: {client.pop_verified}\")</p> <pre><code>result = await client.call_tool(\"read_file\", {\"path\": \"/data/file.txt\"})\n</code></pre> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>class CapiscioMCPClient:\n    \"\"\"\n    MCP Client with automatic server identity and PoP verification.\n\n    This class wraps MCP client functionality to:\n    1. Generate PoP request (nonce) for initialize request\n    2. Verify server identity and PoP response on connection\n    3. Enforce trust level requirements\n    4. Include caller credentials in tool requests\n\n    Attributes:\n        server_url: URL of the MCP server\n        min_trust_level: Minimum required trust level\n        fail_on_unverified: If True, raise on unverified servers\n        require_pop: If True, require PoP verification (did:key servers)\n        pop_verified: Whether PoP verification succeeded\n\n    Example:\n        async with CapiscioMCPClient(\n            server_url=\"https://mcp.example.com\",\n            min_trust_level=2,\n            require_pop=True,\n            badge=\"eyJhbGc...\",  # Your client badge\n        ) as client:\n            # Server identity and PoP already verified\n            print(f\"Trusted at level {client.server_trust_level}\")\n            print(f\"PoP verified: {client.pop_verified}\")\n\n            result = await client.call_tool(\"read_file\", {\"path\": \"/data/file.txt\"})\n    \"\"\"\n\n    def __init__(\n        self,\n        server_url: str,\n        min_trust_level: int = 0,\n        fail_on_unverified: bool = True,\n        require_pop: bool = False,\n        verify_config: Optional[VerifyConfig] = None,\n        badge: Optional[str] = None,\n        api_key: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize CapiscIO MCP Client.\n\n        Args:\n            server_url: URL of the MCP server\n            min_trust_level: Minimum required server trust level\n            fail_on_unverified: If True, raise when server doesn't disclose identity\n            require_pop: If True, require PoP verification for did:key servers\n            verify_config: Full verification configuration\n            badge: Client badge for authentication (recommended)\n            api_key: Client API key for authentication (alternative)\n        \"\"\"\n        _require_mcp_client()\n\n        self.server_url = server_url\n        self.min_trust_level = min_trust_level\n        self.fail_on_unverified = fail_on_unverified\n        self.require_pop = require_pop\n        self.verify_config = verify_config or VerifyConfig(min_trust_level=min_trust_level)\n\n        # Client credentials\n        self._credential = CallerCredential(\n            badge_jws=badge,\n            api_key=api_key,\n        )\n\n        self._client: Optional[McpClient] = None\n        self._session: Optional[Any] = None\n        self._verify_result: Optional[VerifyResult] = None\n\n        # PoP state\n        self._pop_request: Optional[PoPRequest] = None\n        self._pop_response: Optional[PoPResponse] = None\n        self._pop_verified: bool = False\n\n    def create_initialize_request_meta(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Create the _meta object for initialize request.\n\n        This should be called when building the initialize request.\n        It generates a PoP nonce to be signed by the server.\n\n        Returns:\n            Dict to include as _meta in initialize request\n\n        Example:\n            # In your client code\n            meta = client.create_initialize_request_meta()\n            result = await session.initialize(\n                client_info=ClientInfo(...),\n                _meta=meta,\n            )\n        \"\"\"\n        self._pop_request = generate_pop_request()\n        return self._pop_request.to_meta()\n\n    def verify_initialize_response(\n        self,\n        response_meta: Optional[Dict[str, Any]],\n        server_public_key: Optional[\"Ed25519PublicKey\"] = None,\n    ) -&gt; bool:\n        \"\"\"\n        Verify the initialize response including PoP.\n\n        This should be called after receiving the initialize response.\n        It extracts the PoP signature and verifies it.\n\n        Args:\n            response_meta: The _meta from initialize response\n            server_public_key: Server's public key for PoP verification\n                              (if None, will try to extract from did:key)\n\n        Returns:\n            True if PoP verification succeeded, False otherwise\n\n        Raises:\n            PoPSignatureError: If PoP verification fails and require_pop=True\n        \"\"\"\n        if response_meta is None:\n            logger.debug(\"No _meta in initialize response\")\n            return False\n\n        # Extract PoP response\n        self._pop_response = PoPResponse.from_meta(response_meta)\n        if self._pop_response is None:\n            logger.debug(\"No PoP response in initialize response\")\n            return False\n\n        if self._pop_request is None:\n            logger.warning(\"PoP response received but no request was sent\")\n            return False\n\n        # Get public key for verification\n        if server_public_key is None:\n            # Try to extract from server DID\n            server_did = response_meta.get(\"capiscio_server_did\")\n            if server_did and server_did.startswith(\"did:key:\"):\n                try:\n                    server_public_key = extract_public_key_from_did_key(server_did)\n                except Exception as e:\n                    logger.warning(f\"Failed to extract public key from DID: {e}\")\n                    if self.require_pop:\n                        raise PoPSignatureError(f\"Cannot extract public key from {server_did}\")\n                    return False\n            else:\n                # For did:web, we'd need to fetch DID document\n                logger.debug(f\"Cannot verify PoP for non-did:key: {server_did}\")\n                return False\n\n        # Verify PoP\n        try:\n            verify_pop_response(\n                request=self._pop_request,\n                response=self._pop_response,\n                public_key=server_public_key,\n            )\n            self._pop_verified = True\n            logger.info(\"PoP verification succeeded\")\n            return True\n        except PoPError as e:\n            logger.warning(f\"PoP verification failed: {e}\")\n            if self.require_pop:\n                raise\n            return False\n\n    @property\n    def pop_verified(self) -&gt; bool:\n        \"\"\"Whether PoP verification succeeded.\"\"\"\n        return self._pop_verified\n\n    async def __aenter__(self) -&gt; \"CapiscioMCPClient\":\n        \"\"\"\n        Async context manager entry.\n\n        Connects to server and verifies identity.\n        \"\"\"\n        await self.connect()\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n    async def connect(self) -&gt; None:\n        \"\"\"\n        Connect to MCP server and verify identity.\n\n        Raises:\n            ServerVerifyError: If server verification fails and fail_on_unverified=True\n            GuardError: If server doesn't meet trust requirements\n        \"\"\"\n        # Connect to MCP server\n        # Implementation depends on MCP SDK transport\n\n        # Extract server identity from initialize response\n        # This is a placeholder - actual implementation depends on MCP SDK\n        server_did: Optional[str] = None\n        server_badge: Optional[str] = None\n\n        # If we get _meta from initialize response:\n        # server_did, server_badge = parse_jsonrpc_meta(init_result.meta)\n\n        # Verify server identity\n        self._verify_result = await verify_server(\n            server_did=server_did,\n            server_badge=server_badge,\n            transport_origin=self.server_url,\n            config=self.verify_config,\n        )\n\n        # Enforce requirements\n        if self.fail_on_unverified and self._verify_result.state == ServerState.UNVERIFIED_ORIGIN:\n            raise ServerVerifyError(\n                error_code=self._verify_result.error_code,\n                detail=f\"Server at {self.server_url} did not disclose identity\",\n                state=self._verify_result.state,\n            )\n\n        if self._verify_result.state == ServerState.DECLARED_PRINCIPAL and self.min_trust_level &gt; 0:\n            raise ServerVerifyError(\n                error_code=self._verify_result.error_code,\n                detail=f\"Server at {self.server_url} did not provide verifiable badge\",\n                state=self._verify_result.state,\n                server_did=self._verify_result.server_did,\n            )\n\n        if (\n            self._verify_result.state == ServerState.VERIFIED_PRINCIPAL\n            and self._verify_result.trust_level is not None\n            and self._verify_result.trust_level &lt; self.min_trust_level\n        ):\n            raise ServerVerifyError(\n                error_code=self._verify_result.error_code,\n                detail=(\n                    f\"Server trust level {self._verify_result.trust_level} \"\n                    f\"is below required {self.min_trust_level}\"\n                ),\n                state=self._verify_result.state,\n                server_did=self._verify_result.server_did,\n            )\n\n        logger.info(\n            f\"Connected to {self.server_url}: \"\n            f\"state={self._verify_result.state.value}, \"\n            f\"trust_level={self._verify_result.trust_level}\"\n        )\n\n    async def close(self) -&gt; None:\n        \"\"\"Close connection to MCP server.\"\"\"\n        if self._session:\n            # Close session\n            pass\n        self._session = None\n        self._client = None\n\n    @property\n    def server_state(self) -&gt; Optional[ServerState]:\n        \"\"\"Server verification state after connection.\"\"\"\n        return self._verify_result.state if self._verify_result else None\n\n    @property\n    def server_trust_level(self) -&gt; Optional[int]:\n        \"\"\"Server trust level if verified.\"\"\"\n        return self._verify_result.trust_level if self._verify_result else None\n\n    @property\n    def server_did(self) -&gt; Optional[str]:\n        \"\"\"Server DID if disclosed.\"\"\"\n        return self._verify_result.server_did if self._verify_result else None\n\n    @property\n    def is_verified(self) -&gt; bool:\n        \"\"\"Check if server identity is cryptographically verified.\"\"\"\n        return (\n            self._verify_result is not None\n            and self._verify_result.state == ServerState.VERIFIED_PRINCIPAL\n        )\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: Optional[Dict[str, Any]] = None,\n    ) -&gt; Any:\n        \"\"\"\n        Call a tool on the verified server.\n\n        Automatically includes client credentials in the request.\n\n        Args:\n            name: Tool name\n            arguments: Tool arguments\n\n        Returns:\n            Tool result\n\n        Raises:\n            RuntimeError: If not connected\n        \"\"\"\n        if self._session is None:\n            raise RuntimeError(\"Client not connected. Use 'async with' context.\")\n\n        # Set credential context for the call\n        token = set_credential(self._credential)\n        try:\n            # Call tool via MCP client\n            # Implementation depends on MCP SDK\n            pass\n        finally:\n            # Reset credential context\n            pass\n\n    async def list_tools(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        List available tools on the server.\n\n        Returns:\n            List of tool definitions\n        \"\"\"\n        if self._session is None:\n            raise RuntimeError(\"Client not connected. Use 'async with' context.\")\n\n        # List tools via MCP client\n        # Implementation depends on MCP SDK\n        return []\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.is_verified","title":"<code>is_verified</code>  <code>property</code>","text":"<p>Check if server identity is cryptographically verified.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.pop_verified","title":"<code>pop_verified</code>  <code>property</code>","text":"<p>Whether PoP verification succeeded.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.server_did","title":"<code>server_did</code>  <code>property</code>","text":"<p>Server DID if disclosed.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.server_state","title":"<code>server_state</code>  <code>property</code>","text":"<p>Server verification state after connection.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.server_trust_level","title":"<code>server_trust_level</code>  <code>property</code>","text":"<p>Server trust level if verified.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> <p>Connects to server and verifies identity.</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def __aenter__(self) -&gt; \"CapiscioMCPClient\":\n    \"\"\"\n    Async context manager entry.\n\n    Connects to server and verifies identity.\n    \"\"\"\n    await self.connect()\n    return self\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.__init__","title":"<code>__init__(server_url, min_trust_level=0, fail_on_unverified=True, require_pop=False, verify_config=None, badge=None, api_key=None)</code>","text":"<p>Initialize CapiscIO MCP Client.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>URL of the MCP server</p> required <code>min_trust_level</code> <code>int</code> <p>Minimum required server trust level</p> <code>0</code> <code>fail_on_unverified</code> <code>bool</code> <p>If True, raise when server doesn't disclose identity</p> <code>True</code> <code>require_pop</code> <code>bool</code> <p>If True, require PoP verification for did:key servers</p> <code>False</code> <code>verify_config</code> <code>Optional[VerifyConfig]</code> <p>Full verification configuration</p> <code>None</code> <code>badge</code> <code>Optional[str]</code> <p>Client badge for authentication (recommended)</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Client API key for authentication (alternative)</p> <code>None</code> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def __init__(\n    self,\n    server_url: str,\n    min_trust_level: int = 0,\n    fail_on_unverified: bool = True,\n    require_pop: bool = False,\n    verify_config: Optional[VerifyConfig] = None,\n    badge: Optional[str] = None,\n    api_key: Optional[str] = None,\n):\n    \"\"\"\n    Initialize CapiscIO MCP Client.\n\n    Args:\n        server_url: URL of the MCP server\n        min_trust_level: Minimum required server trust level\n        fail_on_unverified: If True, raise when server doesn't disclose identity\n        require_pop: If True, require PoP verification for did:key servers\n        verify_config: Full verification configuration\n        badge: Client badge for authentication (recommended)\n        api_key: Client API key for authentication (alternative)\n    \"\"\"\n    _require_mcp_client()\n\n    self.server_url = server_url\n    self.min_trust_level = min_trust_level\n    self.fail_on_unverified = fail_on_unverified\n    self.require_pop = require_pop\n    self.verify_config = verify_config or VerifyConfig(min_trust_level=min_trust_level)\n\n    # Client credentials\n    self._credential = CallerCredential(\n        badge_jws=badge,\n        api_key=api_key,\n    )\n\n    self._client: Optional[McpClient] = None\n    self._session: Optional[Any] = None\n    self._verify_result: Optional[VerifyResult] = None\n\n    # PoP state\n    self._pop_request: Optional[PoPRequest] = None\n    self._pop_response: Optional[PoPResponse] = None\n    self._pop_verified: bool = False\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.call_tool","title":"<code>call_tool(name, arguments=None)</code>  <code>async</code>","text":"<p>Call a tool on the verified server.</p> <p>Automatically includes client credentials in the request.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tool name</p> required <code>arguments</code> <code>Optional[Dict[str, Any]]</code> <p>Tool arguments</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Tool result</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If not connected</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: Optional[Dict[str, Any]] = None,\n) -&gt; Any:\n    \"\"\"\n    Call a tool on the verified server.\n\n    Automatically includes client credentials in the request.\n\n    Args:\n        name: Tool name\n        arguments: Tool arguments\n\n    Returns:\n        Tool result\n\n    Raises:\n        RuntimeError: If not connected\n    \"\"\"\n    if self._session is None:\n        raise RuntimeError(\"Client not connected. Use 'async with' context.\")\n\n    # Set credential context for the call\n    token = set_credential(self._credential)\n    try:\n        # Call tool via MCP client\n        # Implementation depends on MCP SDK\n        pass\n    finally:\n        # Reset credential context\n        pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close connection to MCP server.</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close connection to MCP server.\"\"\"\n    if self._session:\n        # Close session\n        pass\n    self._session = None\n    self._client = None\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to MCP server and verify identity.</p> <p>Raises:</p> Type Description <code>ServerVerifyError</code> <p>If server verification fails and fail_on_unverified=True</p> <code>GuardError</code> <p>If server doesn't meet trust requirements</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Connect to MCP server and verify identity.\n\n    Raises:\n        ServerVerifyError: If server verification fails and fail_on_unverified=True\n        GuardError: If server doesn't meet trust requirements\n    \"\"\"\n    # Connect to MCP server\n    # Implementation depends on MCP SDK transport\n\n    # Extract server identity from initialize response\n    # This is a placeholder - actual implementation depends on MCP SDK\n    server_did: Optional[str] = None\n    server_badge: Optional[str] = None\n\n    # If we get _meta from initialize response:\n    # server_did, server_badge = parse_jsonrpc_meta(init_result.meta)\n\n    # Verify server identity\n    self._verify_result = await verify_server(\n        server_did=server_did,\n        server_badge=server_badge,\n        transport_origin=self.server_url,\n        config=self.verify_config,\n    )\n\n    # Enforce requirements\n    if self.fail_on_unverified and self._verify_result.state == ServerState.UNVERIFIED_ORIGIN:\n        raise ServerVerifyError(\n            error_code=self._verify_result.error_code,\n            detail=f\"Server at {self.server_url} did not disclose identity\",\n            state=self._verify_result.state,\n        )\n\n    if self._verify_result.state == ServerState.DECLARED_PRINCIPAL and self.min_trust_level &gt; 0:\n        raise ServerVerifyError(\n            error_code=self._verify_result.error_code,\n            detail=f\"Server at {self.server_url} did not provide verifiable badge\",\n            state=self._verify_result.state,\n            server_did=self._verify_result.server_did,\n        )\n\n    if (\n        self._verify_result.state == ServerState.VERIFIED_PRINCIPAL\n        and self._verify_result.trust_level is not None\n        and self._verify_result.trust_level &lt; self.min_trust_level\n    ):\n        raise ServerVerifyError(\n            error_code=self._verify_result.error_code,\n            detail=(\n                f\"Server trust level {self._verify_result.trust_level} \"\n                f\"is below required {self.min_trust_level}\"\n            ),\n            state=self._verify_result.state,\n            server_did=self._verify_result.server_did,\n        )\n\n    logger.info(\n        f\"Connected to {self.server_url}: \"\n        f\"state={self._verify_result.state.value}, \"\n        f\"trust_level={self._verify_result.trust_level}\"\n    )\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.create_initialize_request_meta","title":"<code>create_initialize_request_meta()</code>","text":"<p>Create the _meta object for initialize request.</p> <p>This should be called when building the initialize request. It generates a PoP nonce to be signed by the server.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict to include as _meta in initialize request</p> Example Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def create_initialize_request_meta(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create the _meta object for initialize request.\n\n    This should be called when building the initialize request.\n    It generates a PoP nonce to be signed by the server.\n\n    Returns:\n        Dict to include as _meta in initialize request\n\n    Example:\n        # In your client code\n        meta = client.create_initialize_request_meta()\n        result = await session.initialize(\n            client_info=ClientInfo(...),\n            _meta=meta,\n        )\n    \"\"\"\n    self._pop_request = generate_pop_request()\n    return self._pop_request.to_meta()\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.create_initialize_request_meta--in-your-client-code","title":"In your client code","text":"<p>meta = client.create_initialize_request_meta() result = await session.initialize(     client_info=ClientInfo(...),     _meta=meta, )</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.list_tools","title":"<code>list_tools()</code>  <code>async</code>","text":"<p>List available tools on the server.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of tool definitions</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def list_tools(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List available tools on the server.\n\n    Returns:\n        List of tool definitions\n    \"\"\"\n    if self._session is None:\n        raise RuntimeError(\"Client not connected. Use 'async with' context.\")\n\n    # List tools via MCP client\n    # Implementation depends on MCP SDK\n    return []\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPClient.verify_initialize_response","title":"<code>verify_initialize_response(response_meta, server_public_key=None)</code>","text":"<p>Verify the initialize response including PoP.</p> <p>This should be called after receiving the initialize response. It extracts the PoP signature and verifies it.</p> <p>Parameters:</p> Name Type Description Default <code>response_meta</code> <code>Optional[Dict[str, Any]]</code> <p>The _meta from initialize response</p> required <code>server_public_key</code> <code>Optional['Ed25519PublicKey']</code> <p>Server's public key for PoP verification               (if None, will try to extract from did:key)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if PoP verification succeeded, False otherwise</p> <p>Raises:</p> Type Description <code>PoPSignatureError</code> <p>If PoP verification fails and require_pop=True</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def verify_initialize_response(\n    self,\n    response_meta: Optional[Dict[str, Any]],\n    server_public_key: Optional[\"Ed25519PublicKey\"] = None,\n) -&gt; bool:\n    \"\"\"\n    Verify the initialize response including PoP.\n\n    This should be called after receiving the initialize response.\n    It extracts the PoP signature and verifies it.\n\n    Args:\n        response_meta: The _meta from initialize response\n        server_public_key: Server's public key for PoP verification\n                          (if None, will try to extract from did:key)\n\n    Returns:\n        True if PoP verification succeeded, False otherwise\n\n    Raises:\n        PoPSignatureError: If PoP verification fails and require_pop=True\n    \"\"\"\n    if response_meta is None:\n        logger.debug(\"No _meta in initialize response\")\n        return False\n\n    # Extract PoP response\n    self._pop_response = PoPResponse.from_meta(response_meta)\n    if self._pop_response is None:\n        logger.debug(\"No PoP response in initialize response\")\n        return False\n\n    if self._pop_request is None:\n        logger.warning(\"PoP response received but no request was sent\")\n        return False\n\n    # Get public key for verification\n    if server_public_key is None:\n        # Try to extract from server DID\n        server_did = response_meta.get(\"capiscio_server_did\")\n        if server_did and server_did.startswith(\"did:key:\"):\n            try:\n                server_public_key = extract_public_key_from_did_key(server_did)\n            except Exception as e:\n                logger.warning(f\"Failed to extract public key from DID: {e}\")\n                if self.require_pop:\n                    raise PoPSignatureError(f\"Cannot extract public key from {server_did}\")\n                return False\n        else:\n            # For did:web, we'd need to fetch DID document\n            logger.debug(f\"Cannot verify PoP for non-did:key: {server_did}\")\n            return False\n\n    # Verify PoP\n    try:\n        verify_pop_response(\n            request=self._pop_request,\n            response=self._pop_response,\n            public_key=server_public_key,\n        )\n        self._pop_verified = True\n        logger.info(\"PoP verification succeeded\")\n        return True\n    except PoPError as e:\n        logger.warning(f\"PoP verification failed: {e}\")\n        if self.require_pop:\n            raise\n        return False\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer","title":"<code>CapiscioMCPServer</code>","text":"<p>MCP Server with CapiscIO identity disclosure, PoP signing, and tool guarding.</p> <p>This class wraps an MCP Server to: 1. Automatically inject identity into initialize response _meta 2. Sign PoP challenges to prove key ownership (RFC-007) 3. Guard registered tools with @guard decorator</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Server name</p> <code>did</code> <p>Server DID (did:web:... or did:key:...)</p> <code>badge</code> <p>Server trust badge JWS (optional but recommended)</p> <code>default_min_trust_level</code> <p>Default minimum trust level for tools</p> <code>pop_enabled</code> <code>bool</code> <p>Whether PoP signing is available</p> Example <p>server = CapiscioMCPServer(     name=\"filesystem\",     did=\"did:web:mcp.example.com:servers:filesystem\",     badge=os.environ.get(\"SERVER_BADGE\"),     private_key_path=\"/path/to/server.key.pem\", )</p> <p>@server.tool(min_trust_level=2) async def read_file(path: str) -&gt; str:     with open(path) as f:         return f.read()</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>class CapiscioMCPServer:\n    \"\"\"\n    MCP Server with CapiscIO identity disclosure, PoP signing, and tool guarding.\n\n    This class wraps an MCP Server to:\n    1. Automatically inject identity into initialize response _meta\n    2. Sign PoP challenges to prove key ownership (RFC-007)\n    3. Guard registered tools with @guard decorator\n\n    Attributes:\n        name: Server name\n        did: Server DID (did:web:... or did:key:...)\n        badge: Server trust badge JWS (optional but recommended)\n        default_min_trust_level: Default minimum trust level for tools\n        pop_enabled: Whether PoP signing is available\n\n    Example:\n        server = CapiscioMCPServer(\n            name=\"filesystem\",\n            did=\"did:web:mcp.example.com:servers:filesystem\",\n            badge=os.environ.get(\"SERVER_BADGE\"),\n            private_key_path=\"/path/to/server.key.pem\",\n        )\n\n        @server.tool(min_trust_level=2)\n        async def read_file(path: str) -&gt; str:\n            with open(path) as f:\n                return f.read()\n\n        # Run the server\n        await server.run_stdio()\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        did: str,\n        badge: Optional[str] = None,\n        default_min_trust_level: int = 0,\n        version: str = \"1.0.0\",\n        private_key: Optional[\"Ed25519PrivateKey\"] = None,\n        private_key_path: Optional[str] = None,\n        private_key_pem: Optional[Union[str, bytes]] = None,\n        key_id: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize CapiscIO MCP Server.\n\n        Args:\n            name: Server name (shown to clients)\n            did: Server DID for identity disclosure\n            badge: Server badge JWS for identity verification\n            default_min_trust_level: Default minimum trust level for tools\n            version: Server version string\n            private_key: Ed25519 private key for PoP signing (optional)\n            private_key_path: Path to PEM file containing private key (optional)\n            private_key_pem: PEM-encoded private key string/bytes (optional)\n            key_id: Key ID for JWS header (defaults to DID#keys-1)\n        \"\"\"\n        _require_mcp_server()\n\n        self.name = name\n        self.did = did\n        self.badge = badge\n        self.default_min_trust_level = default_min_trust_level\n        self.version = version\n\n        # Load private key for PoP signing\n        self._private_key: Optional[\"Ed25519PrivateKey\"] = None\n        self._key_id = key_id or f\"{did}#keys-1\"\n\n        if private_key is not None:\n            self._private_key = private_key\n        elif private_key_path is not None:\n            self._load_private_key_from_file(private_key_path)\n        elif private_key_pem is not None:\n            self._private_key = load_private_key_from_pem(private_key_pem)\n\n        self._server = McpServer(name)\n        self._tools: Dict[str, Callable] = {}\n        self._tool_configs: Dict[str, GuardConfig] = {}\n\n        self._setup_identity_injection()\n\n    def _load_private_key_from_file(self, path: str) -&gt; None:\n        \"\"\"Load private key from PEM file.\"\"\"\n        if not CRYPTO_AVAILABLE:\n            logger.warning(\n                \"PoP signing requires 'cryptography' package. \"\n                \"Install with: pip install capiscio-mcp[crypto]\"\n            )\n            return\n\n        try:\n            with open(path, \"rb\") as f:\n                pem_data = f.read()\n            self._private_key = load_private_key_from_pem(pem_data)\n            logger.debug(f\"Loaded private key from {path}\")\n        except Exception as e:\n            logger.warning(f\"Failed to load private key from {path}: {e}\")\n\n    @property\n    def pop_enabled(self) -&gt; bool:\n        \"\"\"Check if PoP signing is available.\"\"\"\n        return self._private_key is not None\n\n    def _setup_identity_injection(self) -&gt; None:\n        \"\"\"\n        Set up identity injection into initialize response.\n\n        Per RFC-007 \u00a76.2, server identity is disclosed via _meta in\n        the initialize response.\n        \"\"\"\n        # The MCP SDK provides hooks for customizing responses\n        # This implementation depends on the specific MCP SDK version\n        # For now, we'll store the identity info to be included\n        self._identity_meta = {\n            \"capiscio_server_did\": self.did,\n        }\n        if self.badge:\n            self._identity_meta[\"capiscio_server_badge\"] = self.badge\n\n    def create_initialize_response_meta(\n        self,\n        request_meta: Optional[Dict[str, Any]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Create the _meta object for initialize response.\n\n        This method should be called when building the initialize response.\n        It includes:\n        1. Server identity (DID, badge)\n        2. PoP response (if client sent PoP request and we have a private key)\n\n        Args:\n            request_meta: The _meta from the initialize request (for PoP)\n\n        Returns:\n            Dict to include as _meta in initialize response\n\n        Example:\n            # In your initialize handler\n            def handle_initialize(request):\n                response_meta = server.create_initialize_response_meta(\n                    request_meta=request.params.get(\"_meta\")\n                )\n                return InitializeResult(\n                    capabilities=...,\n                    _meta=response_meta,\n                )\n        \"\"\"\n        meta = self._identity_meta.copy()\n\n        # Handle PoP if client sent nonce and we have a key\n        if self._private_key is not None and request_meta is not None:\n            pop_request = PoPRequest.from_meta(request_meta)\n            if pop_request is not None:\n                try:\n                    pop_response = create_pop_response(\n                        request=pop_request,\n                        private_key=self._private_key,\n                        key_id=self._key_id,\n                    )\n                    meta.update(pop_response.to_meta())\n                    logger.debug(\"Added PoP signature to initialize response\")\n                except Exception as e:\n                    logger.warning(f\"Failed to create PoP response: {e}\")\n\n        return meta\n\n    def tool(\n        self,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        min_trust_level: Optional[int] = None,\n        config: Optional[GuardConfig] = None,\n    ) -&gt; Callable[[Callable[..., Coroutine[Any, Any, T]]], Callable[..., Coroutine[Any, Any, T]]]:\n        \"\"\"\n        Register a tool with CapiscIO guard.\n\n        This decorator:\n        1. Registers the function as an MCP tool\n        2. Wraps it with @guard for access control\n\n        Args:\n            name: Tool name (default: function name)\n            description: Tool description\n            min_trust_level: Minimum trust level (overrides default)\n            config: Full guard configuration\n\n        Returns:\n            Decorator function\n\n        Example:\n            @server.tool(min_trust_level=2)\n            async def execute_query(sql: str) -&gt; list[dict]:\n                ...\n        \"\"\"\n        def decorator(\n            func: Callable[..., Coroutine[Any, Any, T]]\n        ) -&gt; Callable[..., Coroutine[Any, Any, T]]:\n            tool_name = name or func.__name__\n            tool_description = description or func.__doc__ or f\"Tool: {tool_name}\"\n\n            # Build effective config\n            effective_config = config or GuardConfig()\n            if min_trust_level is not None:\n                effective_config.min_trust_level = min_trust_level\n            elif effective_config.min_trust_level == 0:\n                effective_config.min_trust_level = self.default_min_trust_level\n\n            # Apply guard decorator\n            guarded_func = guard(config=effective_config, tool_name=tool_name)(func)\n\n            # Store for registration\n            self._tools[tool_name] = guarded_func\n            self._tool_configs[tool_name] = effective_config\n\n            # Register with MCP server\n            # Note: Registration API depends on MCP SDK version\n            # This is a placeholder for the actual registration\n            logger.debug(f\"Registered tool '{tool_name}' with trust level {effective_config.min_trust_level}\")\n\n            return guarded_func\n\n        return decorator\n\n    @property\n    def server(self) -&gt; \"McpServer\":\n        \"\"\"Access the underlying MCP server.\"\"\"\n        return self._server\n\n    @property\n    def identity_meta(self) -&gt; Dict[str, str]:\n        \"\"\"Get the identity metadata for initialize response.\"\"\"\n        return self._identity_meta.copy()\n\n    async def run_stdio(self) -&gt; None:\n        \"\"\"Run the server over stdio transport.\"\"\"\n        # Implementation depends on MCP SDK\n        pass\n\n    async def run_sse(self, port: int = 8080) -&gt; None:\n        \"\"\"Run the server over SSE transport.\"\"\"\n        # Implementation depends on MCP SDK\n        pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer--run-the-server","title":"Run the server","text":"<p>await server.run_stdio()</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.identity_meta","title":"<code>identity_meta</code>  <code>property</code>","text":"<p>Get the identity metadata for initialize response.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.pop_enabled","title":"<code>pop_enabled</code>  <code>property</code>","text":"<p>Check if PoP signing is available.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.server","title":"<code>server</code>  <code>property</code>","text":"<p>Access the underlying MCP server.</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.__init__","title":"<code>__init__(name, did, badge=None, default_min_trust_level=0, version='1.0.0', private_key=None, private_key_path=None, private_key_pem=None, key_id=None)</code>","text":"<p>Initialize CapiscIO MCP Server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Server name (shown to clients)</p> required <code>did</code> <code>str</code> <p>Server DID for identity disclosure</p> required <code>badge</code> <code>Optional[str]</code> <p>Server badge JWS for identity verification</p> <code>None</code> <code>default_min_trust_level</code> <code>int</code> <p>Default minimum trust level for tools</p> <code>0</code> <code>version</code> <code>str</code> <p>Server version string</p> <code>'1.0.0'</code> <code>private_key</code> <code>Optional['Ed25519PrivateKey']</code> <p>Ed25519 private key for PoP signing (optional)</p> <code>None</code> <code>private_key_path</code> <code>Optional[str]</code> <p>Path to PEM file containing private key (optional)</p> <code>None</code> <code>private_key_pem</code> <code>Optional[Union[str, bytes]]</code> <p>PEM-encoded private key string/bytes (optional)</p> <code>None</code> <code>key_id</code> <code>Optional[str]</code> <p>Key ID for JWS header (defaults to DID#keys-1)</p> <code>None</code> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    did: str,\n    badge: Optional[str] = None,\n    default_min_trust_level: int = 0,\n    version: str = \"1.0.0\",\n    private_key: Optional[\"Ed25519PrivateKey\"] = None,\n    private_key_path: Optional[str] = None,\n    private_key_pem: Optional[Union[str, bytes]] = None,\n    key_id: Optional[str] = None,\n):\n    \"\"\"\n    Initialize CapiscIO MCP Server.\n\n    Args:\n        name: Server name (shown to clients)\n        did: Server DID for identity disclosure\n        badge: Server badge JWS for identity verification\n        default_min_trust_level: Default minimum trust level for tools\n        version: Server version string\n        private_key: Ed25519 private key for PoP signing (optional)\n        private_key_path: Path to PEM file containing private key (optional)\n        private_key_pem: PEM-encoded private key string/bytes (optional)\n        key_id: Key ID for JWS header (defaults to DID#keys-1)\n    \"\"\"\n    _require_mcp_server()\n\n    self.name = name\n    self.did = did\n    self.badge = badge\n    self.default_min_trust_level = default_min_trust_level\n    self.version = version\n\n    # Load private key for PoP signing\n    self._private_key: Optional[\"Ed25519PrivateKey\"] = None\n    self._key_id = key_id or f\"{did}#keys-1\"\n\n    if private_key is not None:\n        self._private_key = private_key\n    elif private_key_path is not None:\n        self._load_private_key_from_file(private_key_path)\n    elif private_key_pem is not None:\n        self._private_key = load_private_key_from_pem(private_key_pem)\n\n    self._server = McpServer(name)\n    self._tools: Dict[str, Callable] = {}\n    self._tool_configs: Dict[str, GuardConfig] = {}\n\n    self._setup_identity_injection()\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.create_initialize_response_meta","title":"<code>create_initialize_response_meta(request_meta=None)</code>","text":"<p>Create the _meta object for initialize response.</p> <p>This method should be called when building the initialize response. It includes: 1. Server identity (DID, badge) 2. PoP response (if client sent PoP request and we have a private key)</p> <p>Parameters:</p> Name Type Description Default <code>request_meta</code> <code>Optional[Dict[str, Any]]</code> <p>The _meta from the initialize request (for PoP)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict to include as _meta in initialize response</p> Example Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def create_initialize_response_meta(\n    self,\n    request_meta: Optional[Dict[str, Any]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create the _meta object for initialize response.\n\n    This method should be called when building the initialize response.\n    It includes:\n    1. Server identity (DID, badge)\n    2. PoP response (if client sent PoP request and we have a private key)\n\n    Args:\n        request_meta: The _meta from the initialize request (for PoP)\n\n    Returns:\n        Dict to include as _meta in initialize response\n\n    Example:\n        # In your initialize handler\n        def handle_initialize(request):\n            response_meta = server.create_initialize_response_meta(\n                request_meta=request.params.get(\"_meta\")\n            )\n            return InitializeResult(\n                capabilities=...,\n                _meta=response_meta,\n            )\n    \"\"\"\n    meta = self._identity_meta.copy()\n\n    # Handle PoP if client sent nonce and we have a key\n    if self._private_key is not None and request_meta is not None:\n        pop_request = PoPRequest.from_meta(request_meta)\n        if pop_request is not None:\n            try:\n                pop_response = create_pop_response(\n                    request=pop_request,\n                    private_key=self._private_key,\n                    key_id=self._key_id,\n                )\n                meta.update(pop_response.to_meta())\n                logger.debug(\"Added PoP signature to initialize response\")\n            except Exception as e:\n                logger.warning(f\"Failed to create PoP response: {e}\")\n\n    return meta\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.create_initialize_response_meta--in-your-initialize-handler","title":"In your initialize handler","text":"<p>def handle_initialize(request):     response_meta = server.create_initialize_response_meta(         request_meta=request.params.get(\"_meta\")     )     return InitializeResult(         capabilities=...,         _meta=response_meta,     )</p>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.run_sse","title":"<code>run_sse(port=8080)</code>  <code>async</code>","text":"<p>Run the server over SSE transport.</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def run_sse(self, port: int = 8080) -&gt; None:\n    \"\"\"Run the server over SSE transport.\"\"\"\n    # Implementation depends on MCP SDK\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.run_stdio","title":"<code>run_stdio()</code>  <code>async</code>","text":"<p>Run the server over stdio transport.</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>async def run_stdio(self) -&gt; None:\n    \"\"\"Run the server over stdio transport.\"\"\"\n    # Implementation depends on MCP SDK\n    pass\n</code></pre>"},{"location":"api-reference/#capiscio_mcp.integrations.mcp.CapiscioMCPServer.tool","title":"<code>tool(name=None, description=None, min_trust_level=None, config=None)</code>","text":"<p>Register a tool with CapiscIO guard.</p> <p>This decorator: 1. Registers the function as an MCP tool 2. Wraps it with @guard for access control</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Tool name (default: function name)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Tool description</p> <code>None</code> <code>min_trust_level</code> <code>Optional[int]</code> <p>Minimum trust level (overrides default)</p> <code>None</code> <code>config</code> <code>Optional[GuardConfig]</code> <p>Full guard configuration</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., Coroutine[Any, Any, T]]], Callable[..., Coroutine[Any, Any, T]]]</code> <p>Decorator function</p> Example <p>@server.tool(min_trust_level=2) async def execute_query(sql: str) -&gt; list[dict]:     ...</p> Source code in <code>capiscio_mcp/integrations/mcp.py</code> <pre><code>def tool(\n    self,\n    name: Optional[str] = None,\n    description: Optional[str] = None,\n    min_trust_level: Optional[int] = None,\n    config: Optional[GuardConfig] = None,\n) -&gt; Callable[[Callable[..., Coroutine[Any, Any, T]]], Callable[..., Coroutine[Any, Any, T]]]:\n    \"\"\"\n    Register a tool with CapiscIO guard.\n\n    This decorator:\n    1. Registers the function as an MCP tool\n    2. Wraps it with @guard for access control\n\n    Args:\n        name: Tool name (default: function name)\n        description: Tool description\n        min_trust_level: Minimum trust level (overrides default)\n        config: Full guard configuration\n\n    Returns:\n        Decorator function\n\n    Example:\n        @server.tool(min_trust_level=2)\n        async def execute_query(sql: str) -&gt; list[dict]:\n            ...\n    \"\"\"\n    def decorator(\n        func: Callable[..., Coroutine[Any, Any, T]]\n    ) -&gt; Callable[..., Coroutine[Any, Any, T]]:\n        tool_name = name or func.__name__\n        tool_description = description or func.__doc__ or f\"Tool: {tool_name}\"\n\n        # Build effective config\n        effective_config = config or GuardConfig()\n        if min_trust_level is not None:\n            effective_config.min_trust_level = min_trust_level\n        elif effective_config.min_trust_level == 0:\n            effective_config.min_trust_level = self.default_min_trust_level\n\n        # Apply guard decorator\n        guarded_func = guard(config=effective_config, tool_name=tool_name)(func)\n\n        # Store for registration\n        self._tools[tool_name] = guarded_func\n        self._tool_configs[tool_name] = effective_config\n\n        # Register with MCP server\n        # Note: Registration API depends on MCP SDK version\n        # This is a placeholder for the actual registration\n        logger.debug(f\"Registered tool '{tool_name}' with trust level {effective_config.min_trust_level}\")\n\n        return guarded_func\n\n    return decorator\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#pypi-installation","title":"PyPI Installation","text":"<pre><code># Standalone (no MCP SDK dependency)\npip install capiscio-mcp\n\n# With MCP SDK integration\npip install capiscio-mcp[mcp]\n\n# With PoP signing/verification (requires cryptography)\npip install capiscio-mcp[crypto]\n\n# Full installation\npip install capiscio-mcp[mcp,crypto]\n</code></pre>"},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<pre><code>uv add capiscio-mcp\nuv add capiscio-mcp --extra mcp\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>capiscio-core (auto-downloaded on first use)</li> </ul>"},{"location":"getting-started/installation/#core-connection-modes","title":"Core Connection Modes","text":"<p>capiscio-mcp connects to capiscio-core for cryptographic operations:</p>"},{"location":"getting-started/installation/#embedded-mode-default","title":"Embedded Mode (Default)","text":"<p>The SDK automatically downloads and manages the core binary:</p> <pre><code>pip install capiscio-mcp\n# Just works! Binary downloaded on first use.\n</code></pre> <p>The binary is cached at <code>~/.capiscio/bin/capiscio</code>.</p>"},{"location":"getting-started/installation/#external-mode","title":"External Mode","text":"<p>Connect to a separately managed core service:</p> <pre><code># Start core in another terminal\ncapiscio mcp serve --listen localhost:50051\n\n# SDK connects to external core\nexport CAPISCIO_CORE_ADDR=\"localhost:50051\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>from capiscio_mcp import MCP_VERSION, CORE_MIN_VERSION\n\nprint(f\"capiscio-mcp version: {MCP_VERSION}\")\nprint(f\"Required core version: {CORE_MIN_VERSION}\")\n</code></pre>"},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>CAPISCIO_CORE_ADDR</code> External core address (embedded mode) <code>CAPISCIO_SERVER_ORIGIN</code> Server origin for guard (auto-detect) <code>CAPISCIO_LOG_LEVEL</code> Logging verbosity <code>info</code>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>Get started with capiscio-mcp in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#server-side-protect-your-tools","title":"Server-Side: Protect Your Tools","text":"<p>The <code>@guard</code> decorator protects MCP tools with trust-level requirements:</p> <pre><code>from capiscio_mcp import guard\n\n@guard(min_trust_level=2)\nasync def read_database(query: str) -&gt; list[dict]:\n    \"\"\"Only agents with Trust Level 2+ can execute this tool.\"\"\"\n    # Your database query logic here\n    return [{\"id\": 1, \"name\": \"Example\"}]\n</code></pre>"},{"location":"getting-started/quickstart/#with-configuration","title":"With Configuration","text":"<pre><code>from capiscio_mcp import guard, GuardConfig\n\nconfig = GuardConfig(\n    min_trust_level=2,\n    trusted_issuers=[\"did:web:registry.capisc.io\"],\n    allowed_tools=[\"read_*\", \"list_*\"],\n    require_badge=True,  # Deny anonymous access\n)\n\n@guard(config=config)\nasync def execute_query(sql: str) -&gt; list[dict]:\n    \"\"\"Execute a SQL query with full policy enforcement.\"\"\"\n    pass\n</code></pre>"},{"location":"getting-started/quickstart/#sync-version","title":"Sync Version","text":"<pre><code>from capiscio_mcp import guard_sync\n\n@guard_sync(min_trust_level=2)\ndef read_database_sync(query: str) -&gt; list[dict]:\n    \"\"\"Synchronous version for non-async code.\"\"\"\n    pass\n</code></pre>"},{"location":"getting-started/quickstart/#client-side-verify-servers","title":"Client-Side: Verify Servers","text":"<p>Before connecting to an MCP server, verify its identity:</p> <pre><code>from capiscio_mcp import verify_server, ServerState\n\nresult = await verify_server(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n)\n\nif result.state == ServerState.VERIFIED_PRINCIPAL:\n    print(f\"\u2705 Trusted server at Level {result.trust_level}\")\nelif result.state == ServerState.DECLARED_PRINCIPAL:\n    print(\"\u26a0\ufe0f Server identity declared but not verified\")\nelif result.state == ServerState.UNVERIFIED_ORIGIN:\n    print(\"\u274c Server did not disclose identity\")\n</code></pre>"},{"location":"getting-started/quickstart/#understanding-server-states","title":"Understanding Server States","text":"State Meaning Action <code>VERIFIED_PRINCIPAL</code> Identity cryptographically verified Safe to proceed <code>DECLARED_PRINCIPAL</code> Identity declared but verification failed Proceed with caution <code>UNVERIFIED_ORIGIN</code> No identity disclosed High risk"},{"location":"getting-started/quickstart/#trust-levels","title":"Trust Levels","text":"Level Name Who Issues Use Case 0 Self-Signed Agent itself (<code>did:key</code>) Development, testing 1 Domain Validated (DV) CapiscIO Registry Production agents 2 Organization Validated (OV) CapiscIO Registry Business agents 3 Extended Validation (EV) CapiscIO Registry Financial, healthcare 4 Continuous Validation (CV) CapiscIO Registry Critical infrastructure"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Server-Side Guide - Full @guard configuration</li> <li>Client-Side Guide - Server verification patterns</li> <li>Evidence Logging - Audit trail configuration</li> <li>MCP SDK Integration - Use with official MCP SDK</li> </ul>"},{"location":"guides/client-side/","title":"Client-Side: Verifying MCP Servers","text":"<p>This guide covers verifying MCP server identity per RFC-007.</p>"},{"location":"guides/client-side/#basic-usage","title":"Basic Usage","text":"<pre><code>from capiscio_mcp import verify_server, ServerState\n\nresult = await verify_server(\n    server_did=\"did:web:mcp.example.com:servers:filesystem\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n)\n\nif result.state == ServerState.VERIFIED_PRINCIPAL:\n    print(f\"\u2705 Server verified at trust level {result.trust_level}\")\nelif result.state == ServerState.DECLARED_PRINCIPAL:\n    print(\"\u26a0\ufe0f Identity declared but verification failed\")\n    print(f\"   Error: {result.error_detail}\")\nelif result.state == ServerState.UNVERIFIED_ORIGIN:\n    print(\"\u274c Server did not disclose any identity\")\n</code></pre>"},{"location":"guides/client-side/#verifyconfig-options","title":"VerifyConfig Options","text":"<pre><code>from capiscio_mcp import verify_server, VerifyConfig\n\nconfig = VerifyConfig(\n    # List of trusted issuer DIDs\n    trusted_issuers=[\n        \"did:web:registry.capisc.io\",\n    ],\n\n    # Minimum trust level required (0-4)\n    min_trust_level=2,\n\n    # Accept self-signed (did:key) servers?\n    accept_level_zero=False,\n\n    # Skip revocation checks (offline mode)?\n    offline_mode=False,\n\n    # Skip host/path binding checks (for trusted gateways)\n    skip_origin_binding=False,\n)\n\nresult = await verify_server(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n    config=config,\n)\n</code></pre>"},{"location":"guides/client-side/#extracting-identity-from-transport","title":"Extracting Identity from Transport","text":""},{"location":"guides/client-side/#from-http-headers","title":"From HTTP Headers","text":"<pre><code>from capiscio_mcp import parse_http_headers, verify_server\n\n# Extract from HTTP response\nheaders = {\n    \"Capiscio-Server-DID\": \"did:web:mcp.example.com\",\n    \"Capiscio-Server-Badge\": \"eyJhbGc...\",\n}\n\nidentity = parse_http_headers(headers)\n\nif identity.has_identity:\n    result = await verify_server(\n        server_did=identity.server_did,\n        server_badge=identity.server_badge,\n        transport_origin=\"https://mcp.example.com\",\n    )\n</code></pre>"},{"location":"guides/client-side/#from-json-rpc-_meta","title":"From JSON-RPC _meta","text":"<pre><code>from capiscio_mcp import parse_jsonrpc_meta, verify_server\n\n# Extract from MCP JSON-RPC response\nresponse = {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {...},\n    \"_meta\": {\n        \"serverDid\": \"did:web:mcp.example.com\",\n        \"serverBadge\": \"eyJhbGc...\",\n    }\n}\n\nidentity = parse_jsonrpc_meta(response.get(\"_meta\", {}))\n\nif identity.has_identity:\n    result = await verify_server(\n        server_did=identity.server_did,\n        server_badge=identity.server_badge,\n    )\n</code></pre>"},{"location":"guides/client-side/#server-states-explained","title":"Server States Explained","text":"State RFC-007 Definition Recommended Action <code>VERIFIED_PRINCIPAL</code> DID verified via badge chain \u2705 Safe to proceed <code>DECLARED_PRINCIPAL</code> DID provided but verification failed \u26a0\ufe0f Warn user, consider blocking <code>UNVERIFIED_ORIGIN</code> No identity material provided \u274c Treat as untrusted"},{"location":"guides/client-side/#error-handling","title":"Error Handling","text":"<pre><code>from capiscio_mcp import verify_server, ServerVerifyError\n\ntry:\n    result = await verify_server(\n        server_did=\"did:web:mcp.example.com\",\n        server_badge=\"eyJhbGc...\",\n        transport_origin=\"https://mcp.example.com\",\n    )\nexcept ServerVerifyError as e:\n    print(f\"Verification error: {e.error_code}\")\n    print(f\"Detail: {e.message}\")\n</code></pre>"},{"location":"guides/client-side/#error-codes","title":"Error Codes","text":"Code Meaning <code>DID_INVALID</code> Server DID is malformed <code>BADGE_INVALID</code> Badge signature invalid <code>BADGE_EXPIRED</code> Badge has expired <code>BADGE_REVOKED</code> Badge has been revoked <code>TRUST_INSUFFICIENT</code> Trust level below minimum <code>ORIGIN_MISMATCH</code> Transport origin doesn't match DID domain <code>PATH_MISMATCH</code> Endpoint path doesn't match DID path <code>ISSUER_UNTRUSTED</code> Badge issuer not in trusted list"},{"location":"guides/client-side/#synchronous-version","title":"Synchronous Version","text":"<pre><code>from capiscio_mcp import verify_server_sync\n\nresult = verify_server_sync(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n)\n</code></pre>"},{"location":"guides/client-side/#strict-mode","title":"Strict Mode","text":"<p>Raises an exception if verification fails:</p> <pre><code>from capiscio_mcp.server import verify_server_strict\n\n# Raises ServerVerifyError if not VERIFIED_PRINCIPAL\nresult = await verify_server_strict(\n    server_did=\"did:web:mcp.example.com\",\n    server_badge=\"eyJhbGc...\",\n    transport_origin=\"https://mcp.example.com\",\n)\n# If we get here, server is verified\nprint(f\"Server trust level: {result.trust_level}\")\n</code></pre>"},{"location":"guides/evidence/","title":"Evidence Logging","text":"<p>Every tool invocation\u2014allowed or denied\u2014produces an evidence record for audit and forensics.</p>"},{"location":"guides/evidence/#what-gets-logged","title":"What Gets Logged","text":"<p>Evidence records include:</p> Field Description <code>evidence_id</code> Unique ID for this record <code>timestamp</code> When the evaluation occurred <code>tool_name</code> Tool that was invoked <code>params_hash</code> SHA-256 hash of parameters (not raw params\u2014PII safe) <code>decision</code> ALLOW or DENY <code>deny_reason</code> Why access was denied (if applicable) <code>agent_did</code> Caller's DID (if authenticated) <code>badge_jti</code> Badge ID (if badge was used) <code>auth_level</code> ANONYMOUS, API_KEY, or BADGE <code>trust_level</code> Caller's trust level (0-4) <code>server_origin</code> Server that processed the request"},{"location":"guides/evidence/#accessing-evidence-on-denial","title":"Accessing Evidence on Denial","text":"<pre><code>from capiscio_mcp import guard, GuardError\n\n@guard(min_trust_level=2)\nasync def sensitive_operation(data: dict) -&gt; dict:\n    pass\n\ntry:\n    result = await sensitive_operation(data={\"key\": \"value\"})\nexcept GuardError as e:\n    print(f\"Denied: {e.reason}\")\n    print(f\"Evidence ID: {e.evidence_id}\")\n    print(f\"Agent DID: {e.agent_did}\")\n    print(f\"Trust Level: {e.trust_level}\")\n</code></pre>"},{"location":"guides/evidence/#evidence-storage","title":"Evidence Storage","text":"<p>Evidence can be stored in multiple backends:</p>"},{"location":"guides/evidence/#local-storage-default","title":"Local Storage (Default)","text":"<p>Evidence stored in <code>~/.capiscio/evidence/</code>:</p> <pre><code>export CAPISCIO_EVIDENCE_DIR=\"$HOME/.capiscio/evidence\"\n</code></pre>"},{"location":"guides/evidence/#registry-storage","title":"Registry Storage","text":"<p>Forward evidence to the CapiscIO Registry:</p> <pre><code>export CAPISCIO_EVIDENCE_MODE=\"registry\"\nexport CAPISCIO_REGISTRY_ENDPOINT=\"https://registry.capisc.io/events\"\nexport CAPISCIO_REGISTRY_API_KEY=\"sk_live_...\"\n</code></pre>"},{"location":"guides/evidence/#hybrid-storage","title":"Hybrid Storage","text":"<p>Store locally AND forward to registry:</p> <pre><code>export CAPISCIO_EVIDENCE_MODE=\"hybrid\"\n</code></pre>"},{"location":"guides/evidence/#parameters-hash","title":"Parameters Hash","text":"<p>Tool parameters are never sent to the core or logged directly. Instead, a deterministic hash is computed:</p> <pre><code>from capiscio_mcp import compute_params_hash\n\nparams = {\"query\": \"SELECT * FROM users\", \"limit\": 10}\nhash_value = compute_params_hash(params)\n\nprint(hash_value)\n# SHA-256 of canonical JSON: \"a1b2c3d4...\"\n</code></pre> <p>This keeps PII out of evidence records while allowing correlation.</p>"},{"location":"guides/evidence/#querying-evidence","title":"Querying Evidence","text":"<p>Evidence records can be queried via:</p> <ol> <li>Local files: JSON files in the evidence directory</li> <li>Registry API: Query via CapiscIO Registry (requires API key)</li> </ol>"},{"location":"guides/evidence/#local-evidence-example","title":"Local Evidence Example","text":"<pre><code>import json\nfrom pathlib import Path\n\nevidence_dir = Path.home() / \".capiscio\" / \"evidence\"\n\nfor evidence_file in evidence_dir.glob(\"*.json\"):\n    with open(evidence_file) as f:\n        record = json.load(f)\n        if record[\"decision\"] == \"deny\":\n            print(f\"Denial: {record['tool_name']} by {record['agent_did']}\")\n</code></pre>"},{"location":"guides/evidence/#evidence-retention","title":"Evidence Retention","text":"<p>Configure retention via environment:</p> <pre><code># Keep evidence for 90 days\nexport CAPISCIO_EVIDENCE_RETENTION_DAYS=\"90\"\n\n# Disable auto-cleanup\nexport CAPISCIO_EVIDENCE_RETENTION_DAYS=\"0\"\n</code></pre>"},{"location":"guides/evidence/#compliance-considerations","title":"Compliance Considerations","text":"<p>Evidence logging helps with:</p> <ul> <li>SOC 2: Audit trail of access decisions</li> <li>GDPR: Parameters are hashed, not stored raw</li> <li>HIPAA: Track who accessed what tools</li> <li>PCI DSS: Monitor privileged operations</li> </ul>"},{"location":"guides/mcp-integration/","title":"MCP SDK Integration","text":"<p>Use capiscio-mcp with the official MCP Python SDK.</p>"},{"location":"guides/mcp-integration/#installation","title":"Installation","text":"<pre><code>pip install capiscio-mcp[mcp]\n</code></pre>"},{"location":"guides/mcp-integration/#server-integration","title":"Server Integration","text":""},{"location":"guides/mcp-integration/#capisciomcpserver","title":"CapiscioMCPServer","text":"<p>The <code>CapiscioMCPServer</code> wraps the MCP SDK server with automatic identity disclosure:</p> <pre><code>from capiscio_mcp.integrations.mcp import CapiscioMCPServer\n\nserver = CapiscioMCPServer(\n    name=\"filesystem\",\n    did=\"did:web:mcp.example.com:servers:filesystem\",\n    badge=\"eyJhbGc...\",  # Server's trust badge\n)\n\n@server.tool(min_trust_level=2)\nasync def read_file(path: str) -&gt; str:\n    \"\"\"Read a file (requires Trust Level 2+).\"\"\"\n    with open(path) as f:\n        return f.read()\n\n@server.tool(min_trust_level=3)\nasync def write_file(path: str, content: str) -&gt; None:\n    \"\"\"Write a file (requires Trust Level 3+).\"\"\"\n    with open(path, \"w\") as f:\n        f.write(content)\n\n# Run the server\nif __name__ == \"__main__\":\n    server.run()\n</code></pre>"},{"location":"guides/mcp-integration/#features","title":"Features","text":"<ul> <li>Automatic identity headers: Adds <code>Capiscio-Server-DID</code> and <code>Capiscio-Server-Badge</code> to responses</li> <li>Trust-level enforcement: Uses <code>@guard</code> under the hood</li> <li>Evidence logging: All tool calls logged automatically</li> </ul>"},{"location":"guides/mcp-integration/#client-integration","title":"Client Integration","text":""},{"location":"guides/mcp-integration/#capisciomcpclient","title":"CapiscioMCPClient","text":"<p>The <code>CapiscioMCPClient</code> wraps the MCP SDK client with automatic server verification:</p> <pre><code>from capiscio_mcp.integrations.mcp import CapiscioMCPClient\n\nasync with CapiscioMCPClient(\n    server_url=\"https://mcp.example.com\",\n    min_trust_level=2,  # Require verified identity\n    badge=\"eyJhbGc...\",  # Your client badge\n) as client:\n    # Server identity already verified on connect\n    print(f\"Connected at trust level {client.server_trust_level}\")\n\n    result = await client.call_tool(\"read_file\", {\"path\": \"/data/file.txt\"})\n</code></pre>"},{"location":"guides/mcp-integration/#features_1","title":"Features","text":"<ul> <li>Automatic verification: Verifies server identity on connection</li> <li>Badge attachment: Attaches your badge to tool calls</li> <li>Error on untrusted: Raises exception if server not verified</li> </ul>"},{"location":"guides/mcp-integration/#manual-integration","title":"Manual Integration","text":"<p>If you're using a custom MCP setup, use the core functions directly:</p>"},{"location":"guides/mcp-integration/#server-side","title":"Server Side","text":"<pre><code>from mcp.server import Server\nfrom capiscio_mcp import guard\n\nserver = Server(\"my-server\")\n\n@server.tool()\n@guard(min_trust_level=2)  # Apply guard to MCP tool\nasync def my_tool(param: str) -&gt; str:\n    return f\"Result: {param}\"\n</code></pre>"},{"location":"guides/mcp-integration/#client-side","title":"Client Side","text":"<pre><code>from mcp.client import Client\nfrom capiscio_mcp import verify_server, parse_http_headers\n\nasync def connect_and_verify(url: str):\n    # Connect to MCP server\n    async with Client(url) as client:\n        # Get server info\n        info = await client.get_server_info()\n\n        # Parse identity from response headers\n        identity = parse_http_headers(client.last_response_headers)\n\n        if identity.has_identity:\n            result = await verify_server(\n                server_did=identity.server_did,\n                server_badge=identity.server_badge,\n                transport_origin=url,\n            )\n\n            if not result.is_verified:\n                raise RuntimeError(f\"Server not verified: {result.error_detail}\")\n\n        # Proceed with verified server\n        return client\n</code></pre>"},{"location":"guides/mcp-integration/#stdio-transport","title":"Stdio Transport","text":"<p>For stdio-based MCP servers, identity is passed via JSON-RPC <code>_meta</code>:</p> <pre><code>from capiscio_mcp import parse_jsonrpc_meta, verify_server\n\n# Server adds identity to _meta\nresponse = {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {...},\n    \"_meta\": {\n        \"serverDid\": \"did:web:example.com\",\n        \"serverBadge\": \"eyJhbGc...\",\n    }\n}\n\n# Client extracts and verifies\nidentity = parse_jsonrpc_meta(response[\"_meta\"])\nresult = await verify_server(\n    server_did=identity.server_did,\n    server_badge=identity.server_badge,\n)\n</code></pre>"},{"location":"guides/server-side/","title":"Server-Side: Guarding MCP Tools","text":"<p>This guide covers protecting MCP tools with the <code>@guard</code> decorator per RFC-006.</p>"},{"location":"guides/server-side/#basic-usage","title":"Basic Usage","text":"<pre><code>from capiscio_mcp import guard\n\n@guard(min_trust_level=2)\nasync def read_file(path: str) -&gt; str:\n    \"\"\"Read a file (requires Trust Level 2+).\"\"\"\n    with open(path) as f:\n        return f.read()\n</code></pre>"},{"location":"guides/server-side/#guardconfig-options","title":"GuardConfig Options","text":"<pre><code>from capiscio_mcp import guard, GuardConfig\n\nconfig = GuardConfig(\n    # Minimum trust level required (0-4)\n    min_trust_level=2,\n\n    # Accept self-signed (did:key) badges?\n    accept_level_zero=False,\n\n    # List of trusted issuer DIDs\n    trusted_issuers=[\n        \"did:web:registry.capisc.io\",\n        \"did:web:internal.example.com\",\n    ],\n\n    # Glob patterns for allowed tool names\n    allowed_tools=[\n        \"read_*\",\n        \"list_*\",\n    ],\n\n    # If True, deny anonymous/API key access\n    require_badge=True,\n\n    # Policy version for tracking\n    policy_version=\"v1.0\",\n)\n\n@guard(config=config)\nasync def execute_query(sql: str) -&gt; list[dict]:\n    pass\n</code></pre>"},{"location":"guides/server-side/#handling-denials","title":"Handling Denials","text":"<pre><code>from capiscio_mcp import guard, GuardError\n\n@guard(min_trust_level=2)\nasync def sensitive_operation(data: dict) -&gt; dict:\n    pass\n\ntry:\n    result = await sensitive_operation(data={\"key\": \"value\"})\nexcept GuardError as e:\n    print(f\"Access denied: {e.reason}\")\n    print(f\"Evidence ID: {e.evidence_id}\")  # For audit trail\n    print(f\"Caller DID: {e.agent_did}\")\n</code></pre>"},{"location":"guides/server-side/#deny-reasons","title":"Deny Reasons","text":"Reason Meaning <code>BADGE_MISSING</code> No badge provided <code>BADGE_INVALID</code> Badge signature invalid <code>BADGE_EXPIRED</code> Badge has expired <code>BADGE_REVOKED</code> Badge has been revoked <code>TRUST_INSUFFICIENT</code> Trust level too low <code>TOOL_NOT_ALLOWED</code> Tool not in allowed_tools <code>ISSUER_UNTRUSTED</code> Badge issuer not trusted <code>POLICY_DENIED</code> Custom policy denied access"},{"location":"guides/server-side/#different-trust-levels-for-different-tools","title":"Different Trust Levels for Different Tools","text":"<pre><code>from capiscio_mcp import guard\n\n@guard(min_trust_level=1)\nasync def list_files(directory: str) -&gt; list[str]:\n    \"\"\"Low-risk: List files (DV sufficient).\"\"\"\n    pass\n\n@guard(min_trust_level=2)\nasync def read_file(path: str) -&gt; str:\n    \"\"\"Medium-risk: Read file contents (OV required).\"\"\"\n    pass\n\n@guard(min_trust_level=3)\nasync def write_file(path: str, content: str) -&gt; None:\n    \"\"\"High-risk: Write files (EV required).\"\"\"\n    pass\n\n@guard(min_trust_level=4)\nasync def execute_command(cmd: str) -&gt; str:\n    \"\"\"Critical: Execute shell commands (CV required).\"\"\"\n    pass\n</code></pre>"},{"location":"guides/server-side/#context-access","title":"Context Access","text":"<p>Access caller information within guarded functions:</p> <pre><code>from capiscio_mcp import guard\nfrom capiscio_mcp.guard import get_caller_credential\n\n@guard(min_trust_level=2)\nasync def audit_operation(data: dict) -&gt; dict:\n    credential = get_caller_credential()\n\n    if credential:\n        print(f\"Caller DID: {credential.agent_did}\")\n        print(f\"Trust Level: {credential.trust_level}\")\n        print(f\"Badge JTI: {credential.badge_jti}\")\n\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"guides/server-side/#mcp-sdk-integration","title":"MCP SDK Integration","text":"<p>See MCP SDK Integration for using <code>@guard</code> with the official MCP SDK.</p>"}]}